<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>all</title>
<link rel=stylesheet
    href="/concepts/concepts.css" type="text/css" />
</head>
<body>
<font size="-1">
<div id="title">
<center>

<br/>
<span class="smaller">Prerequisite Concepts for Analysis of Algorithms</span>
<br/>
<br/>
Basic Data Structures (Version 7)
<br/>

<span class="smaller"><span class="smaller">
<a href="all.pdf">Printable Version</a>
</span></span>

<br/>


</center>
</div>
<!-- UNIT_SEQUENCE -->
<!-- section -->
<h2> <b>Concept:</b> <i>mathematics notation</i>
<br/>
</h2><!-- section ENDED -->
<!-- selection -->

<!-- 10 questions in this selection -->
<!-- 3 items needed -->
<!-- selection array: 1 0 0 0 1 0 0 0 1 0 -->
<!-- QA -->
<ol type="1" start="1">
<li>
 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msub>		<mi>log</mi>		<mn>2</mn>	</msub>	<mi>n</mi></mrow></math> is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&omega;</mi>	<mrow>		<mo form="prefix">(</mo>		<msub>			<mi>log</mi>			<mn>10</mn>		</msub>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>o</mi>	<mrow>		<mo form="prefix">(</mo>		<msub>			<mi>log</mi>			<mn>10</mn>		</msub>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msub>			<mi>log</mi>			<mn>10</mn>		</msub>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="2">
<li>
 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msub>		<mi>log</mi>		<mn>2</mn>	</msub>	<mi>n</mi></mrow></math> is equal to:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mfrac linethickness="1">		<mrow>			<msub>				<mi>log</mi>				<mn>2</mn>			</msub>			<mi>n</mi>		</mrow>		<mrow>			<msub>				<mi>log</mi>				<mn>10</mn>			</msub>			<mn>2</mn>		</mrow>	</mfrac></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mfrac linethickness="1">		<mrow>			<msub>				<mi>log</mi>				<mn>2</mn>			</msub>			<mi>n</mi>		</mrow>		<mrow>			<msub>				<mi>log</mi>				<mn>2</mn>			</msub>			<mn>10</mn>		</mrow>	</mfrac></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mfrac linethickness="1">		<mrow>			<msub>				<mi>log</mi>				<mn>10</mn>			</msub>			<mi>n</mi>		</mrow>		<mrow>			<msub>				<mi>log</mi>				<mn>10</mn>			</msub>			<mn>2</mn>		</mrow>	</mfrac></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mfrac linethickness="1">		<mrow>			<msub>				<mi>log</mi>				<mn>10</mn>			</msub>			<mi>n</mi>		</mrow>		<mrow>			<msub>				<mi>log</mi>				<mn>2</mn>			</msub>			<mn>10</mn>		</mrow>	</mfrac></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="3">
<li>
 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>log</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>m</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math> is equal to:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>m</mi>	<mi>log</mi>	<mi>n</mi></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msup>		<mrow>			<mo form="prefix">(</mo>			<mi>log</mi>			<mi>n</mi>			<mo form="postfix">)</mo>		</mrow>		<mi>m</mi>	</msup></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>log</mi>	<mi>n</mi>	<mo>+</mo>	<mi>log</mi>	<mi>m</mi></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>n</mi>	<mi>log</mi>	<mi>m</mi></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="4">
<li>
 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>log</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mi>m</mi>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math> is equal to:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>n</mi>	<mi>log</mi>	<mi>m</mi></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msup>		<mrow>			<mo form="prefix">(</mo>			<mi>log</mi>			<mi>n</mi>			<mo form="postfix">)</mo>		</mrow>		<mi>m</mi>	</msup></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>log</mi>	<mi>n</mi>	<mo>+</mo>	<mi>log</mi>	<mi>m</mi></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>m</mi>	<mi>log</mi>	<mi>n</mi></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="5">
<li>
 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msub>		<mi>log</mi>		<mn>2</mn>	</msub>	<mn>2</mn></mrow></math> can be simplified to:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> 2
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msub>		<mi>log</mi>		<mn>2</mn>	</msub>	<mn>2</mn></mrow></math> cannot be simplified any further
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 4
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>1
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="6">
<li>
 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msup>		<mn>2</mn>		<mrow>			<msub>				<mi>log</mi>				<mn>2</mn>			</msub>			<mi>n</mi>		</mrow>	</msup></mrow></math> is equal to:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msup>		<mi>n</mi>		<mn>2</mn>	</msup></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msub>		<mi>log</mi>		<mn>2</mn>	</msub>	<mi>n</mi></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li><i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msup>		<mn>2</mn>		<mi>n</mi>	</msup></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="7">
<li>
 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msup>		<mi>n</mi>		<mn>2</mn>	</msup></mrow></math> is <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>o</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>3</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>. Therefore, <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>log</mi>	<msup>		<mi>n</mi>		<mn>2</mn>	</msup></mrow></math> is <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mo>?</mo>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<msup>			<mi>n</mi>			<mn>3</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>.
Choose the tightest bound.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> little omicron
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> little omega
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>theta
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> big omega
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> big omicron
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="8">
<li>
 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>log</mi>	<msup>		<mi>n</mi>		<mi>n</mi>	</msup></mrow></math> is <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mo>?</mo>		<mo form="postfix">)</mo>	</mrow></mrow></math>.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> log <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msup>		<mi>n</mi>		<mrow>			<mi>log</mi>			<mi>n</mi>		</mrow>	</msup></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> log <i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li><i>n</i> log <i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i>
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="9">
<li>
 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>log</mi>	<msup>		<mn>2</mn>		<mi>n</mi>	</msup></mrow></math> is <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mo>?</mo>		<mo form="postfix">)</mo>	</mrow></mrow></math>.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msup>		<mn>2</mn>		<mi>n</mi>	</msup></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>n</mi>	<mi>log</mi>	<mi>n</mi></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>log</mi>	<mi>n</mi></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li><i>n</i>
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="10">
<li>
 The number of permutations of a list of <i>n</i> items is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msup>		<mn>2</mn>		<mi>n</mi>	</msup></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li><i>n</i>!
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>n</mi>	<mi>log</mi>	<mi>n</mi></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>log</mi>	<mi>n</mi></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- section -->
<h2> <b>Concept:</b> relative growth rates
<br/>
</h2><!-- section ENDED -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 0 -->
<!-- QA -->
<ol type="1" start="11">
<li>
 What is the correct ordering of growth rates for the following functions:

<ul>

<li>

 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow>	<mo>=</mo>	<msup>		<mi>n</mi>		<mn>0.9</mn>	</msup>	<mi>log</mi>	<mi>n</mi></mrow></math>
</li>

<li>

 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>g</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow>	<mo>=</mo>	<mn>1.</mn>	<msup>		<mn>1</mn>		<mi>n</mi>	</msup></mrow></math>
</li>

<li>

 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>h</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow>	<mo>=</mo>	<mn>9.9</mn>	<mi>n</mi></mrow></math>
</li>

</ul>



<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li><i>f < h < g</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <i>g < f < h</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <i>h < f < g</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <i>g < h < f</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <i>f < g < h</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <i>h < g < f</i>
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="12">
<li>
 What is the correct ordering of growth rates for the following functions:

<ul>

<li>

 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow>	<mo>=</mo>	<mi>n</mi>	<msup>		<mrow>			<mo form="prefix">(</mo>			<mi>log</mi>			<mi>n</mi>			<mo form="postfix">)</mo>		</mrow>		<mn>2</mn>	</msup></mrow></math>
</li>

<li>

 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>g</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow>	<mo>=</mo>	<mi>n</mi>	<mi>log</mi>	<msup>		<mn>2</mn>		<mi>n</mi>	</msup></mrow></math>
</li>

<li>

 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>h</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow>	<mo>=</mo>	<mi>n</mi>	<mi>log</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>

</ul>



<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li><i>g > f > h</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <i>h > g > f</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <i>f > h > g</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <i>h > f > g</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <i>g > h > f</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <i>f > g > h</i>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>order notation</i>
<br/>
</h2><!-- section ENDED -->
<!-- selection -->

<!-- 10 questions in this selection -->
<!-- 2 items needed -->
<!-- selection array: 0 0 0 0 0 0 0 1 1 0 -->
<!-- QA -->
<ol type="1" start="13">
<li>
 What does big Omicron roughly mean?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> worse than
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> better than
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> worse than or the same as
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>better than or the same as
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> the same as
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="14">
<li>
 What does <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>		<mi>&omega;</mi>	</mrow></math> roughly mean?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> worse than or the same as
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> better than
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> the same as
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> better than or the same as
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li>worse than
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="15">
<li>
 What does <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi></mrow></math> roughly mean?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>the same as
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> worse than
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> better than or the same as
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> worse than or the same as
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> better than
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="16">
<li>
 <b>T</b> or <b>F</b>:
All algorithms are <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&omega;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="17">
<li>
 <b>T</b> or <b>F</b>:
All algorithms are <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>		<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow>	</mrow></math>.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="18">
<li>
 <b>T</b> or <b>F</b>:
All algorithms are <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Omega;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="19">
<li>
 <b>T</b> or <b>F</b>:
There exist algorithms that are <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&omega;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="20">
<li>
 <b>T</b> or <b>F</b>:
There exist algorithms that are <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>		<mi>O</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow>	</mrow></math>.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="21">
<li>
 <b>T</b> or <b>F</b>:
All algorithms are <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>O</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mi>n</mi>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="22">
<li>
 Consider sorting 1,000,000 numbers with mergesort. What
is the time complexity of this operation? [THINK!]

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>constant, because <i>n</i> is fixed
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msup>		<mi>n</mi>		<mn>2</mn>	</msup></mrow></math>, because mergesort takes quadratic time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i>, because mergesort takes <i>n</i> log <i>n</i> time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>comparing algorithms using order notation</i>
<br/>
</h2><!-- section ENDED -->

The phrase <i>by a stopwatch</i> means
the actual amount of time needed for the algorithm to run to
completion, as measured by a stopwatch.
<br/>
<!-- QA -->
<ol type="1" start="23">
<li>
 <b>T</b> or <b>F</b>:
If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>&omega;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>, then
algorithm <i>f</i> always runs faster than <i>g</i> (by a stopwatch), in all cases.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="24">
<li>
 <b>T</b> or <b>F</b>:
If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>&omega;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math> and the input causes worst-case behaviors, then
algorithm <i>f</i> always runs faster than <i>g</i> (by a stopwatch),
regardless of input size.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="25">
<li>
 <b>T</b> or <b>F</b>:
If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>&omega;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math> and the input causes worst-case behaviors, then
algorithm <i>f</i> always runs faster than <i>g</i> (by a stopwatch),
above a certain input size.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="26">
<li>
 <b>T</b> or <b>F</b>:
If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>&omega;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>, then
algorithm <i>f</i> always runs faster than <i>g</i> (by a stopwatch),
above a certain input size.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="27">
<li>
 <b>T</b> or <b>F</b>:
If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>, then
algorithm <i>f</i> always takes the same time as <i>g</i> (by a stopwatch),
in all cases.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="28">
<li>
 <b>T</b> or <b>F</b>:
If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math> and the input causes worst-case behaviors, then
algorithm <i>f</i> always takes the same time as <i>g</i> (by a stopwatch),
regardless of input size.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="29">
<li>
 <b>T</b> or <b>F</b>:
If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math> and the input causes worst-case behaviors, then
algorithm <i>f</i> always takes the same time as <i>g</i> (by a stopwatch),
above a certain input size.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="30">
<li>
 <b>T</b> or <b>F</b>:
If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>, then
algorithm <i>f</i> always takes the same time as <i>g</i> (by a stopwatch),
above a certain input size.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="31">
<li>
 <b>T</b> or <b>F</b>:
If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>, then
algorithm <i>f</i> always takes the same time as <i>g</i> (within a constant factor),
in all cases.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="32">
<li>
 <b>T</b> or <b>F</b>:
If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math> and the input causes worst-case behaviors, then
algorithm <i>f</i> always takes the same time as <i>g</i> (within a constant factor),
regardless of input size.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="33">
<li>
 <b>T</b> or <b>F</b>:
If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math> and the input causes worst-case behaviors, then
algorithm <i>f</i> always takes the same time as <i>g</i> (within a constant factor),
above a certain input size.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="34">
<li>
 <b>T</b> or <b>F</b>:
If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>, then
algorithm <i>f</i> always takes the same time as <i>g</i> (within a constant factor),
above a certain input size.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="35">
<li>
 <b>T</b> or <b>F</b>:
If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>&omega;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>, then
<i>f</i> and <i>g</i> can be the same algorithm.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="36">
<li>
 <b>T</b> or <b>F</b>:
If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>&Omega;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>, then
<i>f</i> and <i>g</i> can be the same algorithm.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="37">
<li>
 <b>T</b> or <b>F</b>:
If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>o</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>, then
<i>f</i> and <i>g</i> can be the same algorithm.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="38">
<li>
 <b>T</b> or <b>F</b>:
If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>O</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>, then
<i>f</i> and <i>g</i> can be the same algorithm.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="39">
<li>
 <b>T</b> or <b>F</b>:
Suppose algorithm <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>.
<i>f</i> and <i>g</i> can be the same algorithm.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="40">
<li>
 <b>T</b> or <b>F</b>:
If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>&Omega;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>g</mi>	<mo>=</mo>	<mi>O</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>f</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>,
then <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="41">
<li>
 <b>T</b> or <b>F</b>:
If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>f</mi>	<mo>=</mo>	<mi>&Omega;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>g</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>g</mi>	<mo>=</mo>	<mi>O</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>f</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>,
then <i>f</i> and <i>g</i> must be the same algorithm.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>analyzing code</i>
<br/>
</h2><!-- section ENDED -->

In the pseudocode, the lower limit of a 
<code>for</code> loop
is inclusive, while the upper limit is exclusive.
The additive step, if not specified, is one.
<!-- subsection -->
<h3> Tracing recursive functions
<br/>
</h3><!-- subsection ENDED -->

When asked about the number of recursive calls, do not include
the original call.
<br/>
<!-- selection -->

<!-- 4 questions in this selection -->
<!-- 2 items needed -->
<!-- selection array: 0 0 1 1 -->
<!-- QA -->
<ol type="1" start="42">
<li>
 How many recursive calls are made if <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>n</mi>	<mo>=</mo>	<mn>5</mn></mrow></math>?
Assume the initial value of <i>i</i> is zero.

<pre>
    function f(i,n)
        {
        if (i &lt; n)
            {
            println(i);
            f(i+1,n);
            }
        return 0;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> 3
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 4
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> the function recurs infinitely
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 6
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> none of the other answers are correct
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li>5
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="43">
<li>
 How many recursive calls are made if <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>n</mi>	<mo>=</mo>	<mn>81</mn></mrow></math>.
Assume the initial value of <i>i</i> is one.

<pre>
    function f(i,n)
        {
        if (i &lt; n)
            {
            println(i);
            f(i*3,n);
            }
        return 0;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> the function recurs infinitely
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> none of the other answers are correct
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 3
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>4
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> 5
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> 6
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="44">
<li>
 How many recursive calls are made if <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>n</mi>	<mo>=</mo>	<mn>64</mn></mrow></math>.
Assume the initial value of <i>i</i> is one.

<pre>
    function f(i,n)
        {
        if (i &lt; n)
            {
            println(i);
            f(i*sqrt(n),n);
            }
        return 0;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> none of the other answers are correct
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 4
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 7
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 9
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li>2
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> 1
</li>
<!-- answer ENDED -->
<!--ItemCount: 6 -->
<!-- answer -->
<!-- answer -->
<li> 8
</li>
<!-- answer ENDED -->
<!--ItemCount: 7 -->
<!-- answer -->
<!-- answer -->
<li> the function recurs infinitely
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="45">
<li>
 How many recursive calls are made if <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>n</mi>	<mo>=</mo>	<mn>64</mn></mrow></math>.
Assume the initial value of <i>i</i> is zero.

<pre>
    function f(i,n)
        {
        if (i &lt; n)
            {
            println(i);
            f(i+sqrt(n),n);
            }
        return 0;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> the function recurs infinitely
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 2
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 1
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 9
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> 7
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> none of the other answers are correct
</li>
<!-- answer ENDED -->
<!--ItemCount: 6 -->
<!-- answer -->
<!-- answer -->
<li>8
</li>
<!-- answer ENDED -->
<!--ItemCount: 7 -->
<!-- answer -->
<!-- answer -->
<li> 4
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- subsection -->
<h3> Time complexity, recursive functions, single recursion
<br/>
</h3><!-- subsection ENDED -->
<!-- selection -->

<!-- 4 questions in this selection -->
<!-- 2 items needed -->
<!-- selection array: 0 1 0 1 -->
<!-- QA -->
<ol type="1" start="46">
<li>
 What is the time complexity of this function?
Assume the initial value of <i>i</i> is zero.

<pre>
    function f(i,n)
        {
        if (i &lt; n)
            {
            println(i);
            f(i+1,n);
            }
        return 0;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="47">
<li>
 What is the time complexity of this function?
Assume the initial value of <i>i</i> is one.

<pre>
    function f(i,n)
        {
        if (i &lt; n)
            {
            println(i);
            f(i*3,n);
            }
        return 0;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mrow>				<mo form="prefix">(</mo>				<mi>log</mi>				<mi>n</mi>				<mo form="postfix">)</mo>			</mrow>			<mn>3</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="48">
<li>
 What is the time complexity of this function?
Assume the initial value of <i>i</i> is one.

<pre>
    function f(i,n)
        {
        if (i &lt; n)
            {
            f(i*sqrt(n),n);
            println(i);
            }
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="49">
<li>
 What is the time complexity of this function?
Assume positive, integral input and integer division.

<pre>
    function f(n)
        {
        if (n &gt; 0)
            {
            for (var i from 0 until n)
                println(n);
            f(n/2);
            }
        return 0;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- subsection -->
<h3> Time complexity, recursive functions, double recursion
<br/>
</h3><!-- subsection ENDED -->
<!-- selection -->

<!-- 5 questions in this selection -->
<!-- 0 items needed -->
<!-- subsection -->
<h3> Space complexity, recursive functions, single recursion
<br/>
</h3><!-- subsection ENDED -->
<!-- selection -->

<!-- 5 questions in this selection -->
<!-- 2 items needed -->
<!-- selection array: 1 1 0 0 0 -->
<!-- QA -->
<ol type="1" start="50">
<li>
 What is the space complexity of this function?
Assume positive, integral input and integer division.

<pre>
    function f(x,n)
        {
        if (x &gt; 0)
            {
            f(x/2,n);
            for (var i from 0 until n)
                println(n);
            }
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>x</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>x</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>x</mi>		<mo>&sol;</mo>		<mn>2</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>x</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 6 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 7 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>x</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="51">
<li>
 What is the space complexity of this function?
Assume the initial value of <i>i</i> is zero.

<pre>
    function f(i,n)
        {
        if (i &lt; n)
            {
            f(i+2,n);
            println(i);
            }
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="52">
<li>
 What is the space complexity of this function?
Assume the initial value of <i>i</i> is one.

<pre>
    function f(i,n)
        {
        if (i &lt; n)
            {
            f(i*3,n);
            println(i);
            }
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="53">
<li>
 What is the space complexity of this function?
Assume the initial value of <i>i</i> is one.

<pre>
    function f(i,n)
        {
        if (i &lt; n)
            {
            f(i*sqrt(n),n);
            println(i);
            }
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo>-</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mfrac linethickness="1">			<mi>n</mi>			<mrow>				<msqrt>					<mi>n</mi>				</msqrt>			</mrow>		</mfrac>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="54">
<li>
 What is the space complexity of this function?
Assume the initial value of <i>i</i> is one.

<pre>
    function f(i,n)
        {
        if (i &lt; n)
            {
            f(i+sqrt(n),n);
            println(i);
            }
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo>-</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mfrac linethickness="1">			<mi>n</mi>			<mrow>				<msqrt>					<mi>n</mi>				</msqrt>			</mrow>		</mfrac>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- subsection -->
<h3> Space complexity, recursive functions, double recursion
<br/>
</h3><!-- subsection ENDED -->
<!-- selection -->

<!-- 5 questions in this selection -->
<!-- 0 items needed -->
<!-- subsection -->
<h3> Time complexity, iterative loops, single loops
<br/>
</h3><!-- subsection ENDED -->
<!-- selection -->

<!-- 3 questions in this selection -->
<!-- 2 items needed -->
<!-- selection array: 0 1 1 -->
<!-- QA -->
<ol type="1" start="55">
<li>
 What is the time complexity of this code fragment?

<pre>
    for (i from 0 until n by 1)
        println(i);
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>log</mi>			<mn>2</mn>		</msup>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mrow>				<msqrt>					<mi>n</mi>				</msqrt>			</mrow>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="56">
<li>
 What is the time complexity of this code fragment?

<pre>
    i = 1;
    while (i &lt; n)
        {
        println(i);
        i = i * 2;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mrow>				<mo form="prefix">(</mo>				<mi>log</mi>				<mi>n</mi>				<mo form="postfix">)</mo>			</mrow>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="57">
<li>
 What is the time complexity of this code fragment?

<pre>
    i = 1;
    while (i &lt; n)
        {
        println(i);
        i = i * sqrt(n);
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mfrac linethickness="1">			<mi>n</mi>			<mrow>				<msqrt>					<mi>n</mi>				</msqrt>			</mrow>		</mfrac>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo>-</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- subsection -->
<h3> Time complexity, iterative loops, double loops
<br/>
</h3><!-- subsection ENDED -->
<!-- selection -->

<!-- 7 questions in this selection -->
<!-- 2 items needed -->
<!-- selection array: 0 0 1 0 1 0 0 -->
<!-- QA -->
<ol type="1" start="58">
<li>
 What is the time complexity of this code fragment?

<pre>
    for (i from 0 until n by 1)
        for (j from 0 until i by 1)
            println(i,j);
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>log</mi>			<mn>2</mn>		</msup>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="59">
<li>
 What is the time complexity of this code fragment?

<pre>
    i = 1;
    while (i &lt; n)
        {
        for (j from 0 until n by 1)
            println(i,j);
        i = i * 2;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>log</mi>			<mn>2</mn>		</msup>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="60">
<li>
 What is the time complexity of this code fragment?

<pre>
    i = 1;
    while (i &lt; n)
        {
        for (j from 0 until i by 1)
            println(i,j);
        i = i * 2;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>log</mi>			<mn>2</mn>		</msup>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="61">
<li>
 What is the time complexity of this code fragment?

<pre>
    for (i from 0 until n)
        {
        j = 1;
        while (j &lt; n)
            {
            println(i,j);
            j = j * 2;
            }
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>log</mi>			<mn>2</mn>		</msup>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="62">
<li>
 What is the time complexity of this code fragment?

<pre>
    i = 1;
    while (i &lt; n)
        {
        println(i);
        i = i * 2;
        }
    for (j from 0 until n by 2)
        println(j);
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>log</mi>			<mn>2</mn>		</msup>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="63">
<li>
 What is the time complexity of this code fragment?

<pre>
    for (i from 0 until n by 2)
        println(i);
    for (j from 0 until n by 1)
        println(j);
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>log</mi>			<mn>2</mn>		</msup>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="64">
<li>
 What is the time complexity of this code fragment?

<pre>
    for (i from 0 until n by 1)
        println(i);
    j = 1;
    while (j &lt; n)
        {
        println(j);
        j = j * 2;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>log</mi>			<mn>2</mn>		</msup>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- subsection -->
<h3> Space complexity, iterative loops, single loops
<br/>
</h3><!-- subsection ENDED -->
<!-- selection -->

<!-- 3 questions in this selection -->
<!-- 2 items needed -->
<!-- selection array: 1 1 0 -->
<!-- QA -->
<ol type="1" start="65">
<li>
 What is the space complexity of this code fragment?

<pre>
    for (i from 0 until n by 1)
        println(i);
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="66">
<li>
 What is the space complexity of this code fragment?

<pre>
    i = 1;
    while (i &lt; n)
        {
        println(i);
        i = i * sqrt(n);
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="67">
<li>
 What is the space complexity of this code fragment?

<pre>
    i = 1;
    while (i &lt; n)
        {
        println(i);
        i = i * 2;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- subsection -->
<h3> Space complexity, iterative loops, double loops
<br/>
</h3><!-- subsection ENDED -->
<!-- selection -->

<!-- 7 questions in this selection -->
<!-- 2 items needed -->
<!-- selection array: 1 0 0 0 1 0 0 -->
<!-- QA -->
<ol type="1" start="68">
<li>
 What is the space complexity of this code fragment?

<pre>
    for (i from 0 until n by 1)
        println(i);
    for (j from 0 until n by 1)
        println(j);
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="69">
<li>
 What is the space complexity of this code fragment?

<pre>
    i = 1;
    while (i &lt; n)
        {
        println(i);
        i = i * 2;
        }
    for (j from 0 until n by 1)
        println(j);
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="70">
<li>
 What is the space complexity of this code fragment?

<pre>
    for (i from 0 until n by 1)
        println(i);
    j = 1;
    while (j &lt; n)
        {
        println(j);
        j = j * 2;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="71">
<li>
 What is the space complexity of this code fragment?

<pre>
    for (i from 0 until n by 1)
        for (j from 0 until i by 1)
            println(i,j);
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="72">
<li>
 What is the space complexity of this code fragment?

<pre>
    i = 1;
    while (i &lt; n)
        {
        for (j from 0 until i by 1)
            println(i,j);
        i = i * 2;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="73">
<li>
 What is the space complexity of this code fragment?

<pre>
    for (i from 0 until n)
        {
        j = 1;
        while (j &lt; n)
            {
            println(i,j);
            j = j * 2;
            }
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="74">
<li>
 What is the space complexity of this code fragment?

<pre>
    i = 1;
    while (i &lt; n)
        {
        for (j from 0 until n by 1)
            println(i,j);
        i = i * 2;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>n</mi>			<mn>2</mn>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>analysis of classic, simple algorithms</i>
<br/>
</h2><!-- section ENDED -->
<!-- selection -->

<!-- 4 questions in this selection -->
<!-- 2 items needed -->
<!-- selection array: 1 1 0 0 -->
<!-- QA -->
<ol type="1" start="75">
<li>
 Which of the following describes the classic recursive fibonacci's time complexity?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mfrac linethickness="1">			<mi>n</mi>			<mrow>				<msqrt>					<mi>n</mi>				</msqrt>			</mrow>		</mfrac>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo>-</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>&Phi;</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mfrac linethickness="1">			<mi>&Phi;</mi>			<mi>n</mi>		</mfrac>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 6 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msup>			<mi>&Phi;</mi>			<mi>n</mi>		</msup>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="76">
<li>
 Which of the following describes the classic recursive fibonacci's space complexity?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo>-</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mfrac linethickness="1">			<mi>&Phi;</mi>			<mi>n</mi>		</mfrac>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mfrac linethickness="1">			<mi>n</mi>			<mrow>				<msqrt>					<mi>n</mi>				</msqrt>			</mrow>		</mfrac>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="77">
<li>
 Which of the following describes iterative factorial's time complexity?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mfrac linethickness="1">			<mi>n</mi>			<mrow>				<msqrt>					<mi>n</mi>				</msqrt>			</mrow>		</mfrac>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo>-</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mfrac linethickness="1">			<mi>&Phi;</mi>			<mi>n</mi>		</mfrac>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="78">
<li>
 Which of the following describes iterative fibonacci's space complexity?
<br/>

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mfrac linethickness="1">			<mi>&Phi;</mi>			<mi>n</mi>		</mfrac>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mfrac linethickness="1">			<mi>n</mi>			<mrow>				<msqrt>					<mi>n</mi>				</msqrt>			</mrow>		</mfrac>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo>-</mo>		<msqrt>			<mi>n</mi>		</msqrt>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- section -->
<h2> <b>Concept</b>: searching
<br/>
</h2><!-- section ENDED -->
<!-- selection -->

<!-- 4 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 0 0 1 0 -->
<!-- QA -->
<ol type="1" start="79">
<li>
 <b>T</b> or <b>F</b>:
The following code reliably sets the variable <i>min</i> to
the minimum value of an unsorted, non-empty array.

<pre>
    min = 0;
    for (i from 0 until array.length)
        if (array[i] &lt; min)
            min = array[i];
</pre>


<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="80">
<li>
 <b>T</b> or <b>F</b>:
The following code reliably sets the variable <i>max</i> to
the maximum value in an unsorted, non-empty array.

<pre>
    max = array[0]
    for (i from 0 to array.length)
        if (array[i] &gt; max)
            max = array[i]
</pre>


<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="81">
<li>
 <b>T</b> or <b>F</b>:
The following function reliably returns

<code>True</code> if the value of item is <i>present</i> in the unsorted,
non-empty array.

<pre>
    function find(array,item)
        {
        found = False;
        for (i from 0 until array.length)
            if (array[i] == item)
                found = True;
        return found;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="82">
<li>
 <b>T</b> or <b>F</b>:
The following function reliably returns

<code>False</code> if the value of item is <i>missing</i> in the unsorted,
non-empty array.

<pre>
    function find(array,item)
        {
        found = True;
        for (i from 0 unitl array.length)
            if (array[i] != item)
                found = False;
        return found;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 0 -->
<!-- QA -->
<ol type="1" start="83">
<li>
 What is the average and worst case time complexity, respectively,
for searching an unordered list?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> log, log
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> linear, log,
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> log, linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>linear, linear
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="84">
<li>
 What is the average and worst case time complexity, respectively,
for searching an ordered list?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>log, log
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> linear, log
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> log, linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> linear, linear
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- section -->
<h2> <b>Concept</b>: sorting
<br/>
</h2><!-- section ENDED -->
<!-- selection -->

<!-- 5 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 0 0 1 0 0 -->
<!-- QA -->
<ol type="1" start="85">
<li>
 The following strategy is employed by which sort:
<i>find the most extreme value in the unsorted portion
and place it at the boundary of the sorted and unsorted
portions</i>?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> bubble sort
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>selection sort
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> mergesort
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> quicksort
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> insertion sort
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> heapsort
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="86">
<li>
 The following strategy is employed by which sort:
<i>sort the lower half of the items to be sorted, then sort the upper half,
then arrange things such that the largest item in the lower half
is less than or equal to the smallest item in the upper half</i> ?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> selection sort
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> heapsort
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> bubble sort
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> insertion sort
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li>mergesort
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> quicksort
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="87">
<li>
 The following strategy is employed by which sort:
<i>take the first value in the unsorted portion and place it
where it belongs in the sorted portion</i>?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> heapsort
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> bubble sort
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> quicksort
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> mergesort
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li>insertion sort
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> selection sort
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="88">
<li>
 The following strategy is employed by which sort:
<i>pick a value and arrange things such that
the largest item in the lower portion is
less than or equal to the value and that
the smallest item in the upper portion is
greater than or equal to the value,
then sort the lower portion, then sort the upper</i> ?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> insertion sort
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> bubble sort
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> selection sort
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> heapsort
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> mergesort
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li>quicksort
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="89">
<li>
 Which sort optimizes the worst case behavior of bubble sort?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>selection sort
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> insertion sort
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> heapsort
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> stooge sort
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> quicksort
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> mergesort
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>space and time complexity</i>
<br/>
</h2><!-- section ENDED -->
<!-- selection -->

<!-- 9 questions in this selection -->
<!-- 2 items needed -->
<!-- selection array: 0 0 1 0 0 0 0 1 0 -->
<!-- QA -->
<ol type="1" start="90">
<li>
 What is the best time case complexity for classical mergesort?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> cubic
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> quadratic
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li><i>n</i> log <i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> log <i>n</i>
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="91">
<li>
 What is the worst case complexity for classical mergesort?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> log <i>n</i>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> cubic
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li><i>n</i> log <i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> quadratic
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="92">
<li>
 If quicksort is implemented such that the
pivot is chosen to be the first element in the array,
the worst case behavior of the sort is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>quadratic
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> exponential
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> log linear
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="93">
<li>
 If quicksort is implemented such that the
a random element is chosen to be the pivot,
the worst case behavior of the sort is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> exponential
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> log linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>quadratic
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="94">
<li>
 What is the best case complexity for quicksort?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> cubic
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li><i>n</i> log <i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> log <i>n</i>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> quadratic
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="95">
<li>
 What is the best case complexity for classical selection sort?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>quadratic
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> log <i>n</i>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> cubic
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> linear
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="96">
<li>
 What is the worst case complexity for classical selection sort?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>quadratic
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> log <i>n</i>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> cubic
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="97">
<li>
 What is the best case complexity for classical insertion sort?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> log <i>n</i>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> quadratic
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> cubic
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="98">
<li>
 What is the worst case complexity for classical insertion sort?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> log <i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>quadratic
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> cubic
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> linear
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>simple arrays</i>
<br/>
</h2><!-- section ENDED -->

Assume zero-based indexing for all arrays.
<br/>
<br/>
In the pseudocode, the lower limit of a 
<code>for</code> loop
is inclusive, while the upper limit is exclusive.
The step, if not specified, is one.
<br/>
<br/>
For all types of fillable arrays, the size is the number of elements
added to the array; the capacity is the maximum
number of elements that can be added to the array.
<br/>
<br/>
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 0 -->
<!-- QA -->
<ol type="1" start="99">
<li>
 Consider a small array <i>a</i> and large array <i>b</i>.
Accessing the element in the first slot
of <i>a</i> takes more/less/the same amount of
time as accessing the element in the first slot of <i>b</i>.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> more time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> it depends on how the arrays were allocated
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> less time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>the same amount of time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="100">
<li>
 Consider a small array <i>a</i> and large array <i>b</i>.
Accessing the element in the last slot of a <i>b</i> takes
more than/less than/the same amount of time as accessing an element in
the middle slot of <i>a</i>. Both indices are supplied.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> more time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> it depends on how the arrays were allocated
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> less time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>the same amount of time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- QA -->
<ol type="1" start="101">
<li>
 Accessing the middle element of an array takes more/less/the same
amount of time than accessing the last element.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> less time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>the same amount of time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> it depends on how the array were allocated
<br/>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> more time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 0 -->
<!-- QA -->
<ol type="1" start="102">
<li>
 What is a major characteristic of a simple array?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> inserting an element between indices <i>i</i> and <i>i+1</i>can be done in constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>getting the value at an index can be done in constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> finding an element can be done in constant time
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="103">
<li>
 What is a <i>not</i> a major characteristic of a simple array?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>finding an element can be done in constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> setting the value at an index can be done in constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> swapping two elements can be done in constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> getting the value at an index can be done in constant time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 0 1 -->
<!-- QA -->
<ol type="1" start="104">
<li>
 Does the following code set the variable <i>v</i> to
the minimum value in an unsorted array
with at least two elements?

<pre>
    v = 0;
    for (i from 0 until array.length)
        if (array[i] &lt; v)
            v = array[i];
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> yes, if all the elements are positive
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>yes, if all the elements are negative
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> always
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> only if the true minimum value is zero
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> only if all elements have the same value
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> never
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="105">
<li>
 Does the following code set the variable <i>v</i> to
the minimum value in an unsorted array
with at least two elements?

<pre>
    v = array[0];
    for (i from 0 until array.length) 
        if (array[i] &lt; v)
            v = array[i];
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> yes, if all the elements are negative
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>only if all elements have the same value
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> yes, if all the elements are positive
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> never
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> only if the true minimum value is at index 0
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> always
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 0 -->
<!-- QA -->
<ol type="1" start="106">
<li>
 Does the following code set the variable <i>v</i> to
the minimum value in an unsorted array
with at least two elements?

<pre>
    v = array[0];
    for (i from 0 until array.length) 
        if (array[i] &gt; v)
            v = array[i];
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>only if all elements have the same value
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> never
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> yes, if all the elements are positive
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> only if the true minimum value is at index 0
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> yes, if all the elements are negative
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> always
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="107">
<li>
 Does the following code set the variable <i>v</i> to
the minimum value in an unsorted, non-empty array?

<pre>
    v = array[0];
    for (i from 0 until array.length) 
        if (array[i] &gt; v)
            v = array[i];
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> only if the true minimum value is at index 0
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> never
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> only if all elements have the same value
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> yes, if all the elements are positive
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li>always
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> yes, if all the elements are negative
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 0 1 -->
<!-- QA -->
<ol type="1" start="108">
<li>
 Does this <i>find</i> function return the expected result?
Assume the array has at least two elements.

<pre>
    function find(array,item)
        {
        var i; var found = False;
        for (i from 0 until array.length)
            if (array[i] == item)
                found = True;
        return found;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> never
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>always
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> only if the item is not in the array
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> only if the item is in the array
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="109">
<li>
 Does this <i>find</i> function return the expected result?
Assume the array has at least two elements.

<pre>
    function find(array,item)
        {
        var i;
        for (i from 0 until array.length)
            if (array[i] == item)
                return False;
        return True;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>never
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> only if the item is in the array
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> always
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> only if the item is not in the array
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 0 -->
<!-- QA -->
<ol type="1" start="110">
<li>
 Is this <i>find</i> function correct?
Assume the array has at least two elements.

<pre>
    function find(array,item)
        {
        var i; var found = True;
        for (i from 0 until array.length)
            if (array[i] != item)
                found = False;
        return found;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> never
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> only if the item is in the array
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>only if the item is not in the array
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> always
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="111">
<li>
 Does this <i>find</i> function return the expected result?
Assume the array has at least two elements.

<pre>
    function find(array,item)
        {
        var i;
        for (i from 0 until array.length)
            if (array[i] == item)
                return True;
        return False;
        }
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> only if the item is in the array
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> never
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>always
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> only if the item is not in the array
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>simple fillable arrays</i>
<br/>
</h2><!-- section ENDED -->
 Assume the back index in a simple fillable array
points to the first available slot.
<br/>
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 0 1 -->
<!-- QA -->
<ol type="1" start="112">
<li>
 What is <i>not</i> a property of a simple fillable array?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> elements are presumed to be contiguous
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> there exists an element that can be removed in constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> elements can be added in constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>the underlying simple array can increase in size
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="113">
<li>
 What is a property of a simple fillable array?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> more that one element can be next to an empty slot
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> an element can be added anywhere in constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> any element can be removed in constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>elements are presumed to be contiguous
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 7 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 0 0 0 0 0 0 1 -->
<!-- QA -->
<ol type="1" start="114">
<li>
 Adding an element at back of a simple fillable
array can be done in:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> linear time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> quadratic time
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> logarithmic time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="115">
<li>
 Removing an element at front of a simple fillable
array can be done in:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> quadratic time
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> logarithmic time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>linear time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="116">
<li>
 Suppose a simple fillable array has size <i>s</i> and capacity <i>c</i>.
The next value to be added to the array will be placed at index:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <i>c</i> + 1
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <i>s</i> + 1
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <i>s</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <i>c</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <i>c</i> - 1
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li><i>s</i> - 1
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="117">
<li>
 Suppose for a simple fillable array,
the size is one less than the capacity.
How many values can still be added?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> two
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> this situation cannot exist
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> zero, the array is full
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>one
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="118">
<li>
 Suppose for a simple fillable array,
the capacity is one less than the size.
How many values can still be added?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> two
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>this situation cannot exist
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> one
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> zero, the array is full
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="119">
<li>
 Suppose a simple fillable array is empty.
The size of the array is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> one
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> the capacity of the array
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> the length of the underlying simple array
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>zero
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="120">
<li>
 Suppose a simple fillable array is full.
The capacity of the array is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> its size minus one
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>the length of the underlying simple array
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> one
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> zero
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 0 -->
<!-- QA -->
<ol type="1" start="121">
<li>
 Which code fragment correctly inserts a new element into
index <i>j</i> of a simple fillable array with size <i>s</i>? Assume there is room
for the new element.

<pre>
    for (i from j until s-2)
        array[i] = array[i+1];
    array[i] = newElement;
    ---
    for (i from s-2 until j)
        array[i+1] = array[i];
    array[i] = newElement;
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> both are correct
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> neither are correct
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> the second fragment
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>the first fragment
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="122">
<li>
 Which code fragment correctly inserts a new element into
index <i>j</i> of an array with size <i>s</i>?

<pre>
    for (i from j until s-2)
        array[i+1] = array[i];
    array[i] = newElement;
    ---
    for (i from s-2 until j)
        array[i] = array[i+1];
    array[i] = newElement;
</pre>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>neither are correct
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> the first fragment
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> the second fragment
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> both are correct
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>circular arrays</i>
<br/>
</h2><!-- section ENDED -->

For circular arrays, assume <i>f</i> is the start index, <i>e</i> is the
end index, <i>s</i> is the
size, and <i>c</i> is the capacity of the array. Both <i>f</i> and <i>e</i>
point to the first available slots.
<br/>
<!-- selection -->

<!-- 9 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 0 0 0 1 0 0 0 0 0 -->
<!-- QA -->
<ol type="1" start="123">
<li>
 What is a property of a theoretical (not practical) circular array?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> any element can be removed in constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> elements do not have to be contiguous
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> an element can be added anywhere in constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>there are two places an element can be added
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="124">
<li>
 What is <i>not</i> a property of a theoretical (not practical) circular array?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>inserting an element in the middle can be done in constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> appending an element can be done in constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> prepending an element can be done in constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> elements are presumed to be contiguous
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="125">
<li>

The next value to be added to the front of a circular
array will be placed at index:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <i>s</i> - <i>f</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <i>f</i> - 1
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li><i>f</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <i>c</i> - <i>f</i>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <i>c</i> - 1
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <i>s</i> + <i>f</i>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="126">
<li>
 Suppose for a circular array,
the size is equal to the capacity. Can a value be added?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>No, the array is completely full
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> Yes, there is room for one more value
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="127">
<li>
 Suppose a circular array is empty. The size of the array is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> the length of the array
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>zero
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> the capacity of the array
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> one
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="128">
<li>
 In a circular array,
which is <i>not</i> a proper way to correct the start index <i>f</i> after
an element is added to the front of the array?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>
<code>f -= 1; f == 0? c - 1 : f;</code>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 
<code>if (f == 0) f = c - 1; else f = f - 1;</code>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 
<code>f = f == 0? c - 1 : f - 1;</code>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 
<code>f -= 1; f = f &lt; 0? c - 1 : f;</code>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> 
<code>f = (f - 1 + c) % c;</code>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="129">
<li>
 <b>T</b> or <b>F</b>:
In a circular array, the start index (after correction)
can never equal the size of the array.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="130">
<li>
 <b>T</b> or <b>F</b>:
In a circular array, the start index (after correction)
can never equal the capacity of the array.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="131">
<li>
 Is a separate end index <i>e</i> needed in a circular array?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>no, it can be computed from <i>s</i>, <i>c</i>, and <i>f</i>.
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> no, it can be computed from <i>s</i> and <i>f</i>.
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> no, it can be computed from <i>c</i> and <i>f</i>.
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> no, it can be computed from <i>s</i> and <i>c</i>.
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> yes
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>dynamic arrays</i>
<br/>
</h2><!-- section ENDED -->
<!-- selection -->

<!-- 6 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 0 0 0 1 0 0 -->
<!-- QA -->
<ol type="1" start="132">
<li>
 What is <i>not</i> a major characteristic of a dynamic array?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> elements are presumed to be contiguous
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> the array can grow to accommodate more elements
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>the only allowed way to grow is doubling the size
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> finding an element takes at most linear time
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> inserting an element in the middle takes linear time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="133">
<li>
 Suppose a dynamic array has size <i>s</i> and capacity <i>c</i>,
with <i>s</i> equal to <i>c</i>. Is the array required to grow
on the next addition?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>no
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> yes
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> yes, but only if the dynamic array is not circular
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="134">
<li>
 Suppose array capacity grows by 50%
every time a dynamic array fills.
If the only events are insertions, the growing events:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> occur more and more frequently
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>occur less and less frequently
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> occur periodically
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> cannot be characterized in terms of frequency
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="135">
<li>
 Suppose array capacity doubles
every time a dynamic array fills,
If the only events are insertions,
the average cost of an insertion, in the limit, is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>constant
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> the log of the size
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> the log of the capacity
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="136">
<li>
 Suppose array capacity grows by 10
every time a dynamic array fills,
If the only events are insertions,
the average cost of an insertion, in the limit, is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> the log of the size
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> constant
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> the log of the capacity
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> quadratic
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="137">
<li>
 Suppose array capacity grows by 10
every time a dynamic array fills,
If the only events are insertions, the growing events:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> occur more and more frequently
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> occur less and less frequently
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>occur periodically
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> cannot be characterized in terms of frequency
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- QA -->
<ol type="1" start="138">
<li>
 If array capacity grows by 10
every time a dynamic array fills,
the average cost of an insertion in the limit is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> constant
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> the log of the size

<br/>

</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> the log of the capacity
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>linear
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>singly-linked lists (insertions)</i>
<br/>
</h2><!-- section ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 0 -->
<!-- QA -->
<ol type="1" start="139">
<li>
 Appending to a singly-linked list
without a tail pointer takes:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i> time
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>linear time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> log time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="140">
<li>
 Appending to a singly-linked list
with a tail pointer takes:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> linear time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i> time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> log time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- QA -->
<ol type="1" start="141">
<li>
 Suppose you have a pointer to a node near the end of
a long singly-linked list.
You can then insert a new node just prior in:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> log time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i> time
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>linear time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> constant time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 0 -->
<!-- QA -->
<ol type="1" start="142">
<li>
 Suppose you have a pointer to a node near the end of
a long singly-linked list.
You can then insert a new node just after in:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i> time
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> log time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> linear time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>constant time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="143">
<li>
 Suppose you have a pointer to a node near the end of a long
singly-linked list.
You can then insert a new node just after
with as few pointer assignments as:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> 1
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 5
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 4
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>2
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> 3
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>singly-linked lists (deletions)</i>
<br/>
</h2><!-- section ENDED -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 -->
<!-- QA -->
<ol type="1" start="144">
<li>
 Removing the first item from a singly-linked list
without a tail pointer takes:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> log time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i> time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> linear time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- QA -->
<ol type="1" start="145">
<li>
 Removing the last item from a singly-linked list
with a tail pointer takes:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i> time
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>linear time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> log time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> constant time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="146">
<li>
 Removing the last item from a singly-linked list
without a tail pointer takes:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>linear time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> log time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i> time
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="147">
<li>
 Removing the first item from a singly-linked list
with a tail pointer takes:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> linear time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> log time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i> time
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="148">
<li>
 In a singly-linked list, you can move the tail pointer back
one node in:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> log time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i> time
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>linear time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="149">
<li>
 Suppose you have a pointer to a node in the middle of a singly-linked list.
You can then delete that node in:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> log time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i> time
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>linear time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>doubly-linked lists (insertions)</i>
<br/>
</h2><!-- section ENDED -->
<!-- QA -->
<ol type="1" start="150">
<li>
 Appending to a non-circular, doubly-linked list
without a tail pointer takes:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i> time
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>linear time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> log time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> constant time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="151">
<li>
 Appending to a non-circular, doubly-linked list
with a tail pointer takes:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> log time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i> time
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> linear time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>constant time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="152">
<li>
 Removing the first item from a non-circular, doubly-linked list
without a tail pointer takes:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> linear time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> log time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i> time
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="153">
<li>
 Suppose you have a pointer to a node in the middle of a doubly-linked list.
You can then insert a new node just after in:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i> time
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> linear time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> log time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="154">
<li>
 Suppose you have a pointer to a node in the middle of a doubly-linked list.
You can then insert a new node just prior
with as few pointer assignments as:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>4
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 3
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 5
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 1
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> 2
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="155">
<li>
 <b>T</b> : <b>F</b>:
Making a doubly-linked list circular
removes the need for a separate tail pointer.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>doubly-linked lists (deletions)</i>
<br/>
</h2><!-- section ENDED -->
<!-- QA -->
<ol type="1" start="156">
<li>
 Removing the first item from a doubly-linked list
with a tail pointer takes:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i> time
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> linear time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> log time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="157">
<li>
 In a doubly-linked list, you can move the tail pointer back
one node in:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> log time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i> time
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> linear time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="158">
<li>
 In a doubly-linked list, what does a tail-pointer gain you?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> the ability to prepend the list in constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> the ability to remove the last element of list in constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> the ability to both prepend and remove the first element of list in constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> the ability to both append and remove the last element of list in constant time

<br/>

</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> the ability to remove the first element of list in constant time
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li>the ability to append the list in constant time
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>input-output order</i>
<br/>
</h2><!-- section ENDED -->
<!-- QA -->
<ol type="1" start="159">
<li>
 These values are pushed onto a stack in the order given: 1 5 9.
A <i>pop</i> operation would return which value?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>9
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 5
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 1
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="160">
<li>
 LIFO ordering is the same as:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> LILO
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>FILO
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> FIFO
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>time and space complexity</i>
<br/>
</h2><!-- section ENDED -->
<!-- QA -->
<ol type="1" start="161">
<li>
 Consider a stack based upon a fillable array
with pushes onto the back of the array.
What is the time complexity of the worst case behavior
for <i>push</i> and <i>pop</i>, respectively?
You may assume there is sufficient space for the <i>push</i> operation.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>constant and constant
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> constant and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> linear and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> linear and constant
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="162">
<li>
 Consider a stack based upon a circular array
with pushes onto the front of the array.
What is the time complexity of the worst case behavior
for <i>push</i> and <i>pop</i>, respectively?
You may assume there is sufficient space for the <i>push</i> operation.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> constant and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> linear and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> linear and constant
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>constant and constant
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 0 1 -->
<!-- QA -->
<ol type="1" start="163">
<li>
 Consider a stack based upon a dynamic array
with pushes onto the back of the array.
What is the time complexity of the worst case behavior
for <i>push</i> and <i>pop</i>, respectively?
You may assume there is sufficient space for the <i>push</i> operation
and that the array never shrinks.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> linear and constant
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> linear and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>constant and constant
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> constant and linear
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="164">
<li>
 Consider a stack based upon a dynamic array
with pushes onto the back of the array.
What is the time complexity of the worst case behavior
for <i>push</i> and <i>pop</i>, respectively?
You may assume there is sufficient space for the <i>push</i> operation
and that the array may shrink.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>constant and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> linear and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> constant and constant
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> linear and constant
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- QA -->
<ol type="1" start="165">
<li>
 Consider a stack based upon a dynamic circular array
with pushes onto the front of the array.
What is the time complexity of the worst case behavior
for <i>push</i> and <i>pop</i>, respectively?
You may assume the array may grow or shrink.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> linear and constant
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>linear and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> constant and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> constant and constant
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="166">
<li>
 Consider a stack based upon a singly-linked list without
a tail pointer with pushes onto the front of the list.
What is the time complexity of the worst case behavior
for <i>push</i> and <i>pop</i>, respectively?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> constant and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> linear and constant
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> linear and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>constant and constant
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="167">
<li>
 Consider a stack based upon a singly-linked list with
a tail pointer with pushes onto the front of the list.
What is the time complexity of the worst case behavior
for <i>push</i> and <i>pop</i>, respectively?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>constant and constant
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> constant and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> linear and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> linear and constant
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="168">
<li>
 Consider a stack based upon a non-circular, doubly-linked list without
a tail pointer with pushes onto the front of the list.
What is the time complexity of the worst case behavior
for <i>push</i> and <i>pop</i>, respectively?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> constant and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>constant and constant
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> linear and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> linear and constant
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="169">
<li>
 Consider a stack based upon a doubly-linked list with
a tail pointer with pushes onto the front of the list.
What is the time complexity of the worst case behavior
for <i>push</i> and <i>pop</i>, respectively?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> constant and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> linear and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>constant and constant
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> linear and constant
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="170">
<li>
 Suppose a simple fillable array with capacity <i>c</i>
is used to implement two stacks,
one growing from each end. The stack sizes at any given time
are stored in <i>i</i> and <i>j</i>, respectively.
If maximum space efficiency is desired,
a reliable condition for the stacks being full is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> 
<code>i == c/2-1 || j == c/2-1</code>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 
<code>i == c/2-1 &amp;&amp; j == c/2-1</code>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 
<code>i == c/2 &amp;&amp; j == c/2</code>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>
<code>i + j == c</code>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> 
<code>i + j == c-2</code>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> 
<code>i == c/2 || j == c/2</code>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>stack applications</i>
<br/>
</h2><!-- section ENDED -->

For the following questions,
assume the tokens in a post-fix equation are processed with the following code,
with all functions having their obvious meanings and integer division.

<pre>
    s.push(readEquationToken());
    s.push(readEquationToken());
    while (moreEquationTokens())
        {
        t = readEquationToken();
        if (isNumber(t))
            s.push(t);
        else /* t must be an operator */
            {
            operandB = s.pop();
            operandA = s.pop();
            result = performOperation(t,operandA,operandB);
            s.push(result);
            }
        }
</pre>

<!-- QA -->
<ol type="1" start="171">
<li>
 If the tokens of the postfix equation 
<code>8 2 3 ^ / 2 3 * + 5 1 * -</code>
are read in the order given,
what are the top two values in <i>s</i> immediately after the result of
the first multiplication is pushed?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>1 6
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 5 6
<br/>

<br/>

</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 3 3
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 1 2
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>input-output order</i>
<br/>
</h2><!-- section ENDED -->
<!-- QA -->
<ol type="1" start="172">
<li>
 These values are enqueued onto a queue in the order
given: 1 5 9 4. A dequeue operation would return which
value?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> 5
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 9
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>1
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 4
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="173">
<li>
 FIFO ordering is the same as:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>LILO
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> FILO
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> LIFO
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>complexity</i>
<br/>
</h2><!-- section ENDED -->
<!-- QA -->
<ol type="1" start="174">
<li>
 Consider a queue based upon a simple fillable array
with enqueues onto the front of the array.
What is the time complexity of the worst case behavior
for <i>enqueue</i> and <i>dequeue</i>, respectively?
Assume there is room for the operations.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>linear and constant
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> constant and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> linear and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> constant and constant
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="175">
<li>
 Consider a queue based upon a circular array
with enqueues onto the front of the array.
What is the time complexity of the worst case behavior
for <i>enqueue</i> and <i>dequeue</i>, respectively?
Assume there is room for the operations.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> constant and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> linear and constant
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> linear and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>constant and constant
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="176">
<li>
 Consider a queue based upon a singly-linked list without
a tail pointer with enqueues onto the front of the list.
What is the time complexity of the worst case behavior
for <i>enqueue</i> and <i>dequeue</i>, respectively?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> linear and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> linear and constant
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>constant and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> constant and constant
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="177">
<li>
 Consider a queue based upon a singly-linked list with
a tail pointer with enqueues onto the front of the list.
What is the time complexity of the worst case behavior
for <i>enqueue</i> and <i>dequeue</i>, respectively?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> linear and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> constant and constant
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>constant and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> linear and constant
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="178">
<li>
 Consider a queue based upon a doubly-linked list with
a tail pointer with enqueues onto the front of the list.
What is the time complexity of the worst case behavior
for <i>enqueue</i> and <i>dequeue</i>, respectively?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> constant and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>constant and constant
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> linear and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> linear and constant
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="179">
<li>
 Consider a queue based upon a non-circular, doubly-linked list without
a tail pointer with enqueues onto the front of the list.
What is the time complexity of the worst case behavior
for <i>enqueue</i> and <i>dequeue</i>, respectively?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> linear and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> constant and constant
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> linear and constant
<br/>

<br/>

</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>constant and linear
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- section -->
<h2> <b>Concept</b>: <i>complexity</i>
<br/>
</h2><!-- section ENDED -->
<!-- QA -->
<ol type="1" start="180">
<li>
 Consider a worst-case binary search tree with <i>n</i> nodes. What is the
average case time complexity for finding a value at a leaf?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> constant
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> log <i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msqrt>		<mi>n</mi>	</msqrt></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> quadratic
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li>linear
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="181">
<li>
 Consider a binary search tree with <i>n</i> nodes. What is the
worst case time complexity for finding a value at a leaf?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> constant
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> quadratic
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> log <i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i> log <i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li>linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msqrt>		<mi>n</mi>	</msqrt></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="182">
<li>
 Consider a binary search tree with <i>n</i> nodes.
What is the minimum and maximum height (using order notation)?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> linear and linear
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> constant and linear
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> log <i>n</i> and log <i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> constant and log <i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li>log <i>n</i> and linear
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- section -->
<h2><b>Concept</b>: <i>balance</i>
<br/>
</h2><!-- section ENDED -->
<!-- QA -->
<ol type="1" start="183">
<li>
 Which ordering of input values builds the most unbalanced BST?
Assume values are inserted from left to right.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> 1 7 2 6 3 5 4
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 4 3 1 6 2 8 7
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>1 2 3 4 5 7 6
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="184">
<li>
 Which ordering of input values builds the most balanced BST?
Assume values are inserted from left to right.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>4 3 1 6 2 8 7
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 1 4 3 2 5 7 6
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 1 2 7 6 0 3 8
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- section -->
<h2><b>Concept</b>: <i>tree shapes</i>
<br/>
</h2><!-- section ENDED -->
<!-- QA -->
<ol type="1" start="185">
<li>
 What is the best definition of a perfect binary tree?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>all null children are equidistant from the root
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> all leaves have zero children
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> all nodes have zero or two children
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> all leaves are equidistant from the root
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="186">
<li>
 Suppose a binary tree has 10 leaves. How many nodes in the
tree must have two children?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>9
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 7
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 8
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 10
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> no limit
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="187">
<li>
 Suppose a binary tree has 10 nodes. How many nodes are
children of some other node in the tree?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> 8
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>9
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 7
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 10
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> no limit
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection -->

<!-- 4 questions in this selection -->
<!-- 2 items needed -->
<!-- selection array: 0 0 1 1 -->
<!-- QA -->
<ol type="1" start="188">
<li>
 Let P0, P1, and P2 refer to nodes that have zero, one or two children,
respectively.
Using the generally accepted definition,
what is a <i>full</i> binary tree?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> all leaves are equidistant from the root
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> all interior nodes P1, except the root
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> all interior nodes are P1
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> all nodes are P2
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> all interior nodes are P2; all leaves are equidistant from the root
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li>all interior nodes are P2
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="189">
<li>
 Let P0, P1, and P2 refer to nodes that have zero, one or two children,
respectively.
Using the generally accepted definition,
what is a <i>perfect</i> binary tree?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> all interior nodes are P2
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> all interior nodes P1, except the root
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> all interior nodes are P1
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>all interior nodes are P2; all leaves are equidistant from the root
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> all leaves are equidistant from the root
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> all nodes are P0 or P2
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="190">
<li>
 Let P0, P1, and P2 refer to nodes that have zero, one or two children,
respectively.
Using the generally accepted definition,
what is a <i>degenerate</i> binary tree?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> all leaves are equidistant from the root
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> all interior nodes are P2; all leaves are equidistant from the root
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> all interior nodes are P2
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> all nodes are P0 or P2
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> all interior nodes P1, except the root
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li>all interior nodes are P1
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="191">
<li>
 Let P0, P1, and P2 refer to nodes that have zero, one or two children,
respectively.
Using the generally accepted definition
of a <i>complete</i> binary tree, which of the following actions
can be used to make any complete tree?
Assume the leftmost and rightmost sets may be empty.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> making the leftmost leaves of a <i>perfect</i> tree P1 or P2
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> making the leftmost leaves of a <i>perfect</i> tree P2
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> another name for a <i>perfect</i> tree
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> making the leftmost leaf of a <i>perfect</i> tree P1
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li>removing the rightmost leaves from a <i>perfect</i> tree
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 0 1 -->
<!-- QA -->
<ol type="1" start="192">
<li>
 <b>T</b> or <b>F</b>:
All <i>perfect</i> trees are <i>full</i> trees.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="193">
<li>
 <b>T</b> or <b>F</b>:
All <i>full</i> trees are <i>complete</i> trees.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- QA -->
<ol type="1" start="194">
<li>
 <b>T</b> or <b>F</b>:
All <i>complete</i> trees are <i>perfect</i> trees.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 0 1 -->
<!-- QA -->
<ol type="1" start="195">
<li>
 How many distinct binary trees can be formed from exactly two nodes
with values 1, 2, or 3 respectively (hint: think about how many permutations of values there are for each tree shape)?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>6
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 4
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 3
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 5
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> 2
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="196">
<li>
 How many distinct binary tree shapes can be formed from exactly two nodes?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>2
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 1
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 4
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 3
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> 5
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- QA -->
<ol type="1" start="197">
<li>
 Let <i>k</i> be the the number of steps from the root to a leaf in a
perfect tree. What are the number of nodes
in the tree?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>		<msup>		<mn>2</mn>		<mi>k</mi>	</msup>	<mo>-</mo>	<mn>1</mn>	</mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msup>		<mn>2</mn>		<mrow>			<mi>k</mi>			<mo>+</mo>			<mn>1</mn>		</mrow>	</msup></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>		<msup>		<mn>2</mn>		<mrow>			<mi>k</mi>			<mo>+</mo>			<mn>1</mn>		</mrow>	</msup>	<mo>-</mo>	<mn>1</mn>	</mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msup>		<mn>2</mn>		<mrow>			<mi>k</mi>			<mo>-</mo>			<mn>1</mn>		</mrow>	</msup>	<mo>+</mo>	<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msup>		<mn>2</mn>		<mrow>			<mi>k</mi>			<mo>-</mo>			<mn>1</mn>		</mrow>	</msup>	<mo>-</mo>	<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="198">
<li>
 Let <i>k</i> be the the number of steps from the root to the furthest leaf in a
binary tree. What would be the minimum number of nodes
in such a tree? Assume <i>k</i> is a power of two.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <i>k</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> (log <i>k</i>) + 1
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li><i>k</i> + 1
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msup>		<mn>2</mn>		<mrow>			<mi>k</mi>			<mo>+</mo>			<mn>1</mn>		</mrow>	</msup></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msup>		<mn>2</mn>		<mrow>			<mi>k</mi>			<mo>+</mo>			<mn>1</mn>		</mrow>	</msup>	<mo>-</mo>	<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> log <i>k</i>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="199">
<li>
 Let <i>k</i> be the the number of steps from the root to the furthest leaf in a
binary tree. What would be the maximum number of nodes
in such a tree? Assume <i>k</i> is a power of two.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <i>k</i> + 1
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msup>		<mn>2</mn>		<mrow>			<mi>k</mi>			<mo>+</mo>			<mn>1</mn>		</mrow>	</msup></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> (log <i>k</i>) + 1
<br/>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> log <i>k</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <i>k</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msup>		<mn>2</mn>		<mrow>			<mi>k</mi>			<mo>+</mo>			<mn>1</mn>		</mrow>	</msup>	<mo>-</mo>	<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- section -->
<h2><b>Concept</b>: <i>ordering in a BST</i>
<br/>
</h2><!-- section ENDED -->
<!-- QA -->
<ol type="1" start="200">
<li>
 For all child nodes in a BST, what relationship holds between the value
of a left child node and the value of its parent?
Assume unique values.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>less than    
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> there is no relationship
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> greater than 
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="201">
<li>
 For all sibling nodes in a BST, what relationship holds between the value
of a left child node and the value of its sibling?
Assume unique values.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> there is no relationship
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>  greater than 
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> less than    
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="202">
<li>
 Which statement is true about
the <i>successor</i> of a node in a BST, if it exists?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> it is always an interior node
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> it may be an ancestor
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> has no right child
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> it is always a leaf node
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li>has no left child
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="203">
<li>
 Consider a node which holds neither the smallest or the
largest value in a BST.
Which statement is true about the node which holds
the next higher value of a node in a BST, if it exists?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>it may be an ancestor
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> it is always an interior node
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> it is always a leaf node
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> has no left child
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> has no right child
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- section -->
<h2><b>Concept</b>: <i>traversals</i>
<br/>
</h2><!-- section ENDED -->
<!-- selection -->

<!-- 3 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 0 0 -->
<!-- QA -->
<ol type="1" start="204">
<li>
 Consider printing out the node values of
a binary tree with 25 nodes to the left of the root
and 38 nodes to the right. How many nodes are processed
before the root's value is printed in a pre-order traversal?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>0
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 54
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 38
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 25
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> none of the other answers are correct
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> 53
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="205">
<li>
 Consider printing out the node values of
a binary tree with 25 nodes to the left of the root
and 38 nodes to the right. How many nodes are processed
before the root's value is printed in an in-order traversal?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> 53
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>25
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 0
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 54
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> none of the other answers are correct
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> 38
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="206">
<li>
 Consider printing out the node values of
a binary tree with 25 nodes to the left of the root
and 38 nodes to the right. How many nodes are processed
before the root's value is printed in a post-order traversal?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> 38
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 25
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>63
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> none of the other answers are correct
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> 0
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> 54
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- QA -->
<ol type="1" start="207">
<li>
 Consider a perfect BST with even values 0 through 12,
to which the value 7 is then added.
Which of the following is an in-order
traversal of the resulting tree?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> 0 2 4 6 7 8 10 12 
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>  12 10 8 7 6 4 2 0 
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>  0 4 2 7 8 10 12 6 
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>  7 0 2 4 6 8 10 12 
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li>  6 2 10 0 4 8 12 7 
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li>  0 2 4 6 8 10 12 7 
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="208">
<li>
 Consider a perfect BST with even values 0 through 12,
to which the value 7 is then added.
Which of the following is a level-order
traversal of the resulting tree?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>  0 2 4 6 7 8 10 12 
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 6 2 10 0 4 8 12 7 
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>  12 10 8 7 6 4 2 0 
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>  0 4 2 7 8 10 12 6 
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li>  0 2 4 6 8 10 12 7 
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li>  7 0 2 4 6 8 10 12 
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection -->

<!-- 4 questions in this selection -->
<!-- 2 items needed -->
<!-- selection array: 0 1 1 0 -->
<!-- QA -->
<ol type="1" start="209">
<li>
 Consider
a level-order traversal
of C B A D F E 
and an in-order traversal
of B C A F D E .
Do these traversals generate a unique tree and, if so,
what is that tree's
pre-order traversal?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>yes, C B A D F E 
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> yes, C B A F D E 
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> no
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> yes, C A D B E F 
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> yes, but the correct answer is not listed
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="210">
<li>
 Consider
an in-order traversal
of B C A F D E 
and a pre-order traversal
of C B A D F E .
Do these traversals generate a unique tree and, if so,
what is that tree's
post-order traversal?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> no
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> yes, F A D B E C 
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>yes, B F E D A C 
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> yes, but the correct answer is not listed
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> yes, B F A E D C 
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="211">
<li>
 Consider
an in-order traversal
of B C A F D E 
and a post-order traversal
of C B A D F E .
Do these traversals generate a unique tree and, if so,
what is that tree's
level-order traversal?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> yes, E A C F B D 
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> yes, E F C D B A 
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> yes, but the correct answer is not listed
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> no
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li>yes, E F A D B C 
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="212">
<li>
 Consider
a level-order traversal
of C F D E B A 
and an pre-order traversal
of C F E A D B .
Do these traversals generate a unique tree and, if so,
what is that tree's
in-order traversal?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> yes, but the correct answer is not listed
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> yes, F A E C B D 
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> yes, F A E C B D 
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> yes, F E A C D B 
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li>no
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- section -->
<h2><b>Concept</b>: <i>insertion and deletion</i>
<br/>
</h2><!-- section ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 0 -->
<!-- QA -->
<ol type="1" start="213">
<li>
 <b>T</b> or <b>F</b>:
Suppose you are given an in-order traversal of
an unbalanced BST.
If you were to insert those values into an empty BST
in the order given,
would the result be a balanced tree?

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="214">
<li>
 <b>T</b> or <b>F</b>:
Suppose you are given a pre-order traversal of
an unbalanced BST.
If you were to insert those values into an empty BST
in the order given,
would the result be a balanced tree?

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 0 -->
<!-- QA -->
<ol type="1" start="215">
<li>
 <b>T</b> or <b>F</b>:
Suppose you are given an in-order traversal of
a balanced BST.
If you were to insert those values into an empty BST
in the order given,
would the result be a balanced tree?

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="216">
<li>
 <b>T</b> or <b>F</b>:
Suppose you are given a pre-order traversal of
a balanced BST.
If you were to insert those values into an empty BST
in the order given,
would the result be a balanced tree?

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- QA -->
<ol type="1" start="217">
<li>
 Suppose 10 values are inserted inserted into an empty BST.
What is the minimum and maximum resulting heights of the tree?
The height is the number of steps from the root to the furthest leaf.

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> 4 and 10
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 3 and 9
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>3 and 10
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 4 and 9
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> 5 and 10
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> 5 and 9
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="218">
<li>
 Which, if any, of these deletion strategies for non-leaf nodes reliably preserve BST ordering?
<ol type="i">

<li>

 Swap the values of the node to be deleted and the smallest leaf node with a larger value, then remove the leaf.
</li>

<li>

 Swap the values of the node to be deleted with its predecessor or successor. If the predecessor or successor is a leaf, remove it. Otherwise, repeat the process.
</li>

<li>

 If the node to be deleted does not have two children, simply connect the parent's child pointer to the node to the node's child pointer, otherwise, use a correct deletion strategy for nodes with two children.
</li>

</ol>



<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> all
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <i>iii</i>
<br/>

<br/>

</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <i>i</i> and <i>iii</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <i>i</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> none
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <i>ii</i> and <i>iii</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 6 -->
<!-- answer -->
<!-- answer -->
<li> <i>ii</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 7 -->
<!-- answer -->
<!-- answer -->
<li> <i>i</i> and <i>ii</i>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <b>heap shapes</b>
<br/>
</h2><!-- section ENDED -->
<!-- QA -->
<ol type="1" start="219">
<li>
 In a heap, the upper bound on the number of leaves is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>O</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>O</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>O</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>O</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="220">
<li>
 In a heap, the distance from the root to the furthest leaf is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="221">
<li>
 In a heap, let <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msub>		<mi>d</mi>		<mi>f</mi>	</msub></mrow></math> be the distance of the furthest leaf from the root
and let <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msub>		<mi>d</mi>		<mi>c</mi>	</msub></mrow></math> be the analogous distance of the closest leaf. What is
<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<msub>		<mi>d</mi>		<mi>f</mi>	</msub>	<mo>-</mo>	<msub>		<mi>d</mi>		<mi>c</mi>	</msub></mrow></math>, at most?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 2
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 0
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>1
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 0 -->
<!-- QA -->
<ol type="1" start="222">
<li>
 What is the most number of nodes in a heap
with a single child?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> 0
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 2
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>1
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="223">
<li>
 What is the fewest number of nodes in a heap
with a single child?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> 0
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> one per level
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>1
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 2
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 0 -->
<!-- QA -->
<ol type="1" start="224">
<li>
 <b>T</b> or <b>F</b>:
There can be two or more nodes in a heap with exactly one child.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="225">
<li>
 <b>T</b> or <b>F</b>:
A heap can have no nodes with exactly one child.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- QA -->
<ol type="1" start="226">
<li>
 <b>T</b> or <b>F</b>:
All heaps are perfect trees.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="227">
<li>
 <b>T</b> or <b>F</b>:
No heaps are perfect trees.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="228">
<li>
 <b>T</b> or <b>F</b>:
All heaps are complete trees.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="229">
<li>
 <b>T</b> or <b>F</b>:
No heaps are complete trees.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="230">
<li>
 <b>T</b> or <b>F</b>:
A binary tree with one node must be a heap.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="231">
<li>
 <b>T</b> or <b>F</b>:
A binary tree with two nodes and with the root having
the smallest value must be a min-heap.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="232">
<li>
 <b>T</b> or <b>F</b>:
If a node in a heap is a right child and has two children,
then its sibling must also have two children.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="233">
<li>
 <b>T</b> or <b>F</b>:
If a node in a heap is a right child and has one child,
then its sibling must also have one child.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <b>heap ordering</b>
<br/>
</h2><!-- section ENDED -->
<!-- QA -->
<ol type="1" start="234">
<li>
 In a min-heap, what is the relationship between a parent
and its left child?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> there is no relationship between their values
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>the parent has a smaller value
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> the parent has a larger value
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> the parent has the same value
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="235">
<li>
 In a min-heap, what is the relationship between a left
child and its sibling?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> the right child has a larger value
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>there is no relationship between their values
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> the left child has a smaller value
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> both children cannot have the same value
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="236">
<li>
 <b>T</b> or <b>F</b>:
A binary tree with three nodes and with the root having
the smallest value and two children must be a min heap.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="237">
<li>
 <b>T</b> or <b>F</b>:
The largest value in a max-heap can be found
at the root.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="238">
<li>
 <b>T</b> or <b>F</b>:
The largest value in a min-heap can be found
at the root.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="239">
<li>
 <b>T</b> or <b>F</b>:
The largest value in a min-heap can be found
at a leaf.

<!-- ANSWER_SEQUENCE -->
</li>
</ol>
<!-- QA ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <b>heaps stored in arrays</b>
<br/>
</h2><!-- section ENDED -->
<!-- QA -->
<ol type="1" start="240">
<li>
 How would this heap be stored in an array?


<br/>
<div class="ldraw">
<image src="/concepts/cs/ds/img-heaps-0-0.png">
</div>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>
<code>[2,10,4,11,13,5,15,21,12]</code>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 
<code>[2,4,5,10,11,12,13,15,21]</code>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 
<code>[2,10,11,21,12,13,4,5,15]</code>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 
<code>[21,11,12,10,13,2,5,4,15]</code>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="241">
<li>
 Printing out the values in the array yield what kind of traversal of
the heap?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> pre-order
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> post-order
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> in-order
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>level-order
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="242">
<li>
 Suppose the heap has <i>n</i> values. The root of the heap can be
found at which index?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> 1
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i>-1
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li>0
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="243">
<li>
 Suppose the heap has <i>n</i> values. The left child of the
root can be found at which index?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li>1
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i>-2
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 2
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 0
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <i>n</i>-1
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 0 1 -->
<!-- QA -->
<ol type="1" start="244">
<li>
 Left children in a heap are stored at what kind of indices?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> all even but one
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>all odd
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> a roughly equal mix of odd and even
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> all odd but one
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> all even
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="245">
<li>
 Right children in a heap are stored at what kind of indices?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> all even but one
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> a roughly equal mix of odd and even
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>all even
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> all odd
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> all odd but one
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 0 1 -->
<!-- QA -->
<ol type="1" start="246">
<li>
 The formula for finding the left child of a node stored at index <i>i</i> is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>2</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>2</mn>	<mo>+</mo>	<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>2</mn>	<mo>-</mo>	<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>2</mn>	<mo>+</mo>	<mn>2</mn></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="247">
<li>
 The formula for finding the right child of a node stored at index <i>i</i> is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>2</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>2</mn>	<mo>+</mo>	<mn>2</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>2</mn>	<mo>+</mo>	<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>2</mn>	<mo>-</mo>	<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- QA -->
<ol type="1" start="248">
<li>
 The formula for finding the parent of a node stored at index <i>i</i> is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mrow>		<mo form="prefix">(</mo>		<mi>i</mi>		<mo>+</mo>		<mn>2</mn>		<mo form="postfix">)</mo>	</mrow>	<mo>&sol;</mo>	<mn>2</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mrow>		<mo form="prefix">(</mo>		<mi>i</mi>		<mo>+</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow>	<mo>&sol;</mo>	<mn>2</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mrow>		<mo form="prefix">(</mo>		<mi>i</mi>		<mo>-</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow>	<mo>&sol;</mo>	<mn>2</mn></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>&sol;</mo>	<mn>2</mn></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 0 1 -->
<!-- QA -->
<ol type="1" start="249">
<li>
 If the array uses one-based indexing, the formula for finding
the left child of a node stored at index <i>i</i> is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>2</mn>	<mo>-</mo>	<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>2</mn>	<mo>+</mo>	<mn>2</mn></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>2</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>2</mn>	<mo>+</mo>	<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="250">
<li>
 If the array uses one-based indexing, the formula for finding
the right child of a node stored at index <i>i</i> is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>2</mn>	<mo>+</mo>	<mn>2</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>2</mn>	<mo>+</mo>	<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>2</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>2</mn>	<mo>-</mo>	<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- QA -->
<ol type="1" start="251">
<li>
 If the array uses one-based indexing, the formula for finding
the parent of a node stored at index <i>i</i> is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mrow>		<mo form="prefix">(</mo>		<mi>i</mi>		<mo>+</mo>		<mn>2</mn>		<mo form="postfix">)</mo>	</mrow>	<mo>&sol;</mo>	<mn>2</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mrow>		<mo form="prefix">(</mo>		<mi>i</mi>		<mo>-</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow>	<mo>&sol;</mo>	<mn>2</mn></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mrow>		<mo form="prefix">(</mo>		<mi>i</mi>		<mo>+</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow>	<mo>&sol;</mo>	<mn>2</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>&sol;</mo>	<mn>2</mn></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection -->

<!-- 3 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 0 1 0 -->
<!-- QA -->
<ol type="1" start="252">
<li>
 Consider a trinary heap stored in
an array.
The formula for finding the left child of a node stored at index <i>i</i> is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>3</mn>		<mo>+</mo>		<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>3</mn>	<mo>-</mo>	<mn>2</mn></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>3</mn>	<mo>+</mo>	<mn>3</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>3</mn>		<mo>-</mo>		<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>3</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>3</mn>	<mo>+</mo>	<mn>2</mn></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="253">
<li>
 Consider a trinary heap stored in
an array.
The formula for finding the middle child of a node stored at index <i>i</i> is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>3</mn>	<mo>+</mo>	<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>3</mn>	<mo>-</mo>	<mn>2</mn></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>3</mn>	<mo>+</mo>	<mn>3</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>		<mn>3</mn>	<mo>+</mo>	<mn>2</mn>	</mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>		<mn>3</mn>	</mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>3</mn>	<mo>-</mo>	<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="254">
<li>
 Consider a trinary heap stored in
an array.
The formula for finding the right child of a node stored at index <i>i</i> is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>3</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>3</mn>	<mo>-</mo>	<mn>2</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>3</mn>	<mo>-</mo>	<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>3</mn>	<mo>+</mo>		<mn>1</mn>	</mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>3</mn>	<mo>+</mo>		<mn>3</mn>	</mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>*</mo>	<mn>3</mn>	<mo>+</mo>	<mn>2</mn></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- QA -->
<ol type="1" start="255">
<li>
 Consider a trinary heap stored in
an array.
The formula for finding the parent of a node stored at index <i>i</i> is:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>		<mrow>		<mo form="prefix">(</mo>		<mi>i</mi>		<mo>-</mo>		<mn>2</mn>		<mo form="postfix">)</mo>	</mrow>	<mo>&sol;</mo>	<mn>3</mn>	</mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mrow>		<mo form="prefix">(</mo>		<mi>i</mi>		<mo>+</mo>		<mn>2</mn>		<mo form="postfix">)</mo>	</mrow>	<mo>&sol;</mo>	<mn>3</mn></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>&sol;</mo>	<mn>3</mn>	<mo>+</mo>	<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>		<mrow>		<mo form="prefix">(</mo>		<mi>i</mi>		<mo>-</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow>	<mo>&sol;</mo>	<mn>3</mn>	</mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mrow>		<mo form="prefix">(</mo>		<mi>i</mi>		<mo>+</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow>	<mo>&sol;</mo>	<mn>3</mn></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>i</mi>	<mo>&sol;</mo>	<mn>3</mn>	<mo>-</mo>	<mn>1</mn></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- section -->
<h2> <b>Concept:</b> <i>heap operations</i>
<br/>
</h2><!-- section ENDED -->
<!-- QA -->
<ol type="1" start="256">
<li>
 In a max-heap with no knowledge of
the minimum value, the minimum value can be found
in time:

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="257">
<li>
 Suppose a min-heap with <i>n</i> values is stored in an array <i>a</i>. In the
<i>extractMin</i> operation, which element immediatelyreplaces the root element
(prior to this new root being sifted down).

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> 
<code>a[2]</code>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> the minimum of 
<code>a[1]</code> and 
<code>a[2]</code>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li>
<code>a[n-1]</code>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 
<code>a[1]</code>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="258">
<li>
 The <i>findMin</i> operation in a min-heap takes how much time?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="259">
<li>
 The <i>extractMin</i> operation in a min-heap takes how much time?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="260">
<li>
 Merging two heaps of size <i>n</i> and <i>m</i>, <i>m</i> < <i>n</i> takes
how much time?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo>*</mo>		<mi>m</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>m</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo>+</mo>		<mi>log</mi>		<mi>m</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo>+</mo>		<mi>m</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo>*</mo>		<mi>log</mi>		<mi>m</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>m</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="261">
<li>
 The <i>insert</i> operation takes how much time?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="262">
<li>
 Turning an unordered array into a heap takes how much time?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mn>1</mn>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>log</mi>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>	<mi>&Theta;</mi>	<mrow>		<mo form="prefix">(</mo>		<mi>n</mi>		<mo form="postfix">)</mo>	</mrow></mrow></math>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="263">
<li>
 Suppose the
values 21, 15, 14, 10, 8, 5, and 2
are inserted, one after the other, into an empty <i>min</i>-heap. What does
the resulting heap look like?
Heap properties are maintained after every insertion.


<br/>
<div class="ldraw">
<image src="/concepts/cs/ds/img-heaps-1-0.png">
</div>


<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> <i>w</i>
<br/>
</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li><i>y</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> <i>z</i>
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> <i>x</i>
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- QA -->
<ol type="1" start="264">
<li>
 Using the standard <i>buildHeap</i> operation to turn an unordered array
into a <i>max</i>-heap, how many parent-child swaps are made if the
initial unordered array
is 
<code>[5,21,8,15,25,3,9]</code>?

<!-- ANSWER_SEQUENCE -->
<ol type="A">
<!--ItemCount: 0 -->
<!-- answer -->
<!-- answer -->
<li> 2

</li>
<!-- answer ENDED -->
<!--ItemCount: 1 -->
<!-- answer -->
<!-- answer -->
<li>4
</li>
<!-- answer ENDED -->
<!--ItemCount: 2 -->
<!-- answer -->
<!-- answer -->
<li> 7
</li>
<!-- answer ENDED -->
<!--ItemCount: 3 -->
<!-- answer -->
<!-- answer -->
<li> 5
</li>
<!-- answer ENDED -->
<!--ItemCount: 4 -->
<!-- answer -->
<!-- answer -->
<li> 3
</li>
<!-- answer ENDED -->
<!--ItemCount: 5 -->
<!-- answer -->
<!-- answer -->
<li> 6
</li>
<!-- answer ENDED -->
</ol>
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- UNIT_SEQUENCE ENDED -->
</body>
</html>
