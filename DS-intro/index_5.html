<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- XML file produced from file: index.tex
     using Hyperlatex v 2.9-in-waiting-rk (oct06) (c) Otfried Cheong
     on Emacs 22.2.1, Mon Aug 18 09:08:14 2014 -->
<head>
<title>An Encyclop&aelig;dia of Elementary Data Structures -- Arrays</title>

<style type="text/css">
.maketitle { align : center }
div.abstract { margin-left: 20%; margin-right: 10%; }
h3.abstract  { align : center }
div.verse, div.quote, div.quotation {
  margin-left : 10%; 
  margin-right : 10%;
}
dt {font-weight: bold}
</style>
</p>
<link rel=stylesheet
        href="lusth.css" type="text/css" />
</head>
<body>
<table width="100%" cellpadding=0 cellspacing=2><tr><td bgcolor="#b2b2b2" ><a href="index_4.html">
  <img border="0" alt="An Introduction to Order Notation" src="previous.png"></a></td><td bgcolor="#b2b2b2" ><a href="index.html">
  <img border="0" alt="Top" src="up.png"></a></td><td bgcolor="#b2b2b2" ><a href="index_6.html">
  <img border="0" alt="Fillable Arrays" src="next.png"></a></td><td bgcolor="#b2b2b2" align="center" width="100%"><font color="#000000"><b></b></font>
    </td><td bgcolor="#b2b2b2" align="center"><a href="index_1.html">Contents</a></td></td></tr></table>
<h1>Arrays</h1>

<h2><a name="id1">Synopsis</a></h2><p>
An array is a fundamental data structure that supports the getting
and setting of values. The size of an array dictates how many
values it can hold. An array of size <i>n</i> can hold <i>n</i> values.
Arrays are distinguished by the fact that getting or setting any
element in the array can be done in constant time, regardless of
the size of the array.
</p>
<p>Arrays may be <i>homogeneous</i> or <i>heterogeneous</i>, depending
on the language. 
In a homogeneous array, all the stored values must have the same
type (<i>e.g.</i> all the elements are integers or all are strings).
In a heterogeneous array,
the values do not need to be of the same type (<i>e.g.</i> the array
can hold both integers and strings).
</p>

<h2><a name="id2">Structure</a></h2><p>
Arrays are typically built in to the language.
</p>

<h2><a name="ArraysVocabulary">Vocabulary</a></h2>
<p>The terms used in describing an array are:
</p>
<dl><dt>element</dt><dd>
A value stored in an array.
Each element is associated with
a unique <i>index</i>. Elements are said to
be <i>stored</i> at an index.
</dd><dt>first element</dt><dd>
The element with the lowest index. Also known as the
<i>leftmost</i> element.
</dd><dt>last element</dt><dd>
The element with the highest index. Also known as
the <i>rightmost</i> element.
</dd><dt>index</dt><dd>
An index is an integer value used to indicate a particular
element in an array.
An array of size <i>n</i> has <i>n</i> indices and holds <i>n</i> elements.
In modern programming languages, a
technique known as <i>zero-based counting</i> is used to
number the elements. Instead
of numbering the elements from leftmost
to rightmost as 1, 2, 3, 4 ..., the elements are numbered
0, 1, 2, 3, ... . Thus, the first element in the array
has index 0, the second, index 1, the third, index 2, and
so on.
</dd><dt>length</dt><dd>
The number of elements in the array. Also known as the 
<i>capacity</i>.
</dd></dl>

<h2><a name="id4">Supports</a></h2><p>
Arrays can be used to implement:
</p>
<ul><li><a href="index_6.html">Fillable Arrays</a>
</li><li><a href="index_18.html">Heaps</a>
</li></ul>

<h2><a name="id5">Dependencies</a></h2><p>
Arrays are usually fundamental data structures provided by the
language processor.
</p>

<h2><a name="id6">Operations</a></h2>

<h3><a name="ArraysGet">get</a></h3>
<p>Languages that support arrays often provide special syntax
for getting an element of an array. For C-based languages,
square brackets are used to indicate which element is to
be gotten; the index of the desired element is placed
between the brackets. The array the element is to be
retrieved from is given immediately before the opening
square bracket. Here are some examples, with <i>items</i>
being the name of the array:
</p>
<pre>
    println(items[0]);                //print the first item
    last = items[length(items) - 1]   //get the last item, assign to last
</pre>
<p>Functional languages may use function calls to get elements
from an array:
</p>
<pre>
    println(array-get(items,0))
    set(last,array-get(items,length(items) - 1));
</pre>
<p>Getting an element takes <i>&#920;(1)</i> time.
</p>

<h3><a name="id8">set</a></h3><p>
Setting an element in an array overwrites the previous
value. Getting an element at an index  always gets
the value most recently set at that index.
In C-based languages, setting looks like getting, except
the array name, brackets, and index appear to the
left of an assignment operator. 
Here are some examples, with <i>items</i>
being the name of the array:
</p>
<pre>
    items[0] = items[1];            //set the first element to the second
    items[length(items) - 1] = 0;   //set the last element to zero
</pre>
<p>Functional languages may use function calls to set elements
from an array:
</p>
<pre>
    array-set(items,0,array-get(items,1))
    array-set(items,length(items) - 1,0)
</pre>
<p>Setting an element takes <i>&#920;(1)</i> time.
</p>

<h2><a name="id9">Traversals</a></h2><p>
Arrays are usually traversed from left to right:
</p>
<pre>
    for (i = 0; i &lt; length(items); i += 1) //zero-based counting!
        println(items[i])
</pre>
<p>However, it is not uncommon to traverse them from right to left:
</p>
<pre>
    for (i = length(items) - 1; i &gt;= 0; i -= 1) //zero-based counting!
        println(items[i])
</pre>

<h2><a name="id10">Concept Inventory</a></h2>
<div align="center">
Array Concept Inventory (C Language)
</div>
<ol>&nbsp;
<li>Consider a small array <i>a</i> and large array <i>b</i>. Accessing the first element of <i>a</i> takes more/less/the same amount of time as accessing the first element of <i>b</i>.
<ol><li>
the same amount of time
</li><li>
more time
</li><li>
less time
</li></ol>
&nbsp;
</li><li>Consider a small array <i>a</i> and large array <i>b</i>. Accessing the last element of <i>a</i> takes more/less/the same amount of time as accessing the first element of <i>b</i>.
<ol><li>
the same amount of time
</li><li>
more time
</li><li>
less time
</li></ol>
&nbsp;
</li><li>C arrays are:
<ol><li>
homogeneous
</li><li>
heterogeneous
</li><li>
neither homogeneous nor heterogeneous
</li><li>
both homogeneous and heterogeneous
</li></ol>
&nbsp;
</li><li>C arrays can be:
<ol><li>
dynamically allocated only
</li><li>
statically allocated only
</li><li>
dynamically and statically allocated
</li><li>
neither dynamically nor statically allocated
</li></ol>
&nbsp;
</li><li>Why is the following array declaration not proper? 
<pre>
    int z1[];
</pre>
<ol><li>
it <i>is</i> proper
</li><li>
the square brackets are in the wrong place
</li><li>
the size of the array is missing
</li><li>
<i>z1</i> is not a legal variable name
</li></ol>
&nbsp;
</li><li>Why is the following array declaration not proper? 
<pre>
    int _[] = { 1 };
</pre>
<ol><li>
it <i>is</i> proper
</li><li>
arrays have to have more than one slot
</li><li>
the size of the array is missing
</li><li>
<i>&#95;</i> is not a legal variable name
</li></ol>
&nbsp;
</li><li>Why is the following array declaration not proper? 
<pre>
    int[1] x = { 1 };
</pre>
<ol><li>
it <i>is</i> proper
</li><li>
arrays have to have more than one slot
</li><li>
the size of the array is missing
</li><li>
the brackets are in the wrong place
</li></ol>
&nbsp;
</li><li>Why is the following array declaration improper? 
<pre>
    int y[2] = { 1, 2, 3 };
</pre>
<ol><li>
it <i>is</i> proper, the array is expanded to three elements
</li><li>
it <i>is</i> proper, the last initializer is ignored
</li><li>
there are too many initializers
</li><li>
there are too few initializers
</li></ol>
&nbsp;
</li><li>Why is the following array declaration improper? 
<pre>
    int w = { 1, 2, 3 };
</pre>
<ol><li>
it <i>is</i> proper
</li><li>
there are too many initializers
</li><li>
there are too few initializers
</li><li>
the square brackets are missing
</li></ol>
&nbsp;
</li><li>Why is the following array declaration improper? 
<pre>
    double y[3] = { 1, 2, 3 };
</pre>
<ol><li>
it <i>is</i> proper
</li><li>
you cannot have integer initializers
</li><li>
you cannot give a size if you have initializers
</li><li>
there should be a comma after the 3
</li></ol>
&nbsp;
</li><li>Why is the following array declaration improper? 
<pre>
    double y[1];
</pre>
<ol><li>
it <i>is</i> proper
</li><li>
initializers are missing
</li><li>
arrays need more than one slot
</li><li>
there should be an empty initializer list
</li></ol>
&nbsp;
</li><li>Why is the following array declaration improper? 
<pre>
    double y[2] = {};
</pre>
<ol><li>
it <i>is</i> proper
</li><li>
there should be initializer values
</li><li>
the initializer list should be <code>{,}</code>
</li><li>
the initializer list should be <code>{}</code>
</li></ol>
&nbsp;
</li><li>Why is the following array declaration improper? 
<pre>
    double y[3] = { 1.1 2.2 3.3 };
</pre>
<ol><li>
it <i>is</i> proper, commas are not necessary
</li><li>
commas after each initializer are missing
</li><li>
commas between initializers are missing
</li></ol>
&nbsp;
</li><li>Why is the following array declaration improper? 
<pre>
    double y[3] = { "1", "2", "3" };
</pre>
<ol><li>
it <i>is</i> proper
</li><li>
you cannot have string initializers
</li><li>
you cannot give a size if you have initializers
</li><li>
there should be a comma after the 3
</li></ol>
&nbsp;
</li><li>Why is the following array declaration improper? 
<pre>
    void y[2];
</pre>
<ol><li>
it <i>is</i> proper
</li><li>
<code>void</code> is not a valid type for arrays
</li><li>
the initializer is missing
</li></ol>
&nbsp;
</li><li>Why is the following array declaration improper? 
<pre>
    void *y[2];
</pre>
<ol><li>
it <i>is</i> proper
</li><li>
<code>void *</code> is not a valid type for arrays
</li><li>
the initializer is missing
</li></ol>
&nbsp;
</li><li><b>T</b> or <b>F</b>: Given the declaration <code>int x[3];</code> and <code>int y[3];</code>, then <code>y[0] = x[0];</code> is a logically correct assignment.
&nbsp;<br />&nbsp;<br />&nbsp;
</li><li><b>T</b> or <b>F</b>: Given the declaration <code>int x[3];</code> and <code>int y[3];</code>, then <code>y[0] = x[1];</code> is a logically correct assignment.
&nbsp;<br />&nbsp;<br />&nbsp;
</li><li><b>T</b> or <b>F</b>: Given the declaration <code>int x[3];</code> and <code>int y[3];</code>, then <code>y[0] = x[3];</code> is a logically correct assignment.
&nbsp;<br />&nbsp;<br />&nbsp;
</li><li><b>T</b> or <b>F</b>: Given the declaration <code>int x[3];</code> and <code>int y[3];</code>, then <code>y[3] = x[2];</code> is a logically correct assignment.
&nbsp;<br />&nbsp;<br />&nbsp;
</li><li>An array has size <i>n</i>. What is the index of the last element?
<ol><li>
<i>n</i>
</li><li>
<i>n - 1</i>
</li><li>
<i>n + 1</i>
</li><li>
<i>n - 2</i>
</li></ol>
&nbsp;
</li><li>You wish to set change the first element in an array <i>a</i> to the value of the last element. Which of the following accomplishes that task?
<ol><li>
<code>a[0] = a[n-1];</code>
</li><li>
<code>a[1] = a[n-1];</code>
</li><li>
<code>a[1] = a[n];</code>
</li><li>
<code>a[0] = a[n];</code>
</li></ol>
&nbsp;
</li><li>You know that the second element of array <i>a</i> holds a valid index for <i>a</i>. You wish to change the element at that index to zero. Which of the following reliably accomplishes that task?
<ol><li>
<code>a[a[1]] = 0;</code>
</li><li>
<code>a = a[a[2]];</code>
</li><li>
<code>a[a[2]] = 0;</code>
</li><li>
<code>a[a[1]] = a[1];</code>
</li></ol>
&nbsp;
</li><li>Consider the declaration <code>int y[3];</code>. As an rvalue, the expression <code>y[2]</code>:
<ol><li>
generates an out-of-bounds error message
</li><li>
references the last element in the array
</li><li>
may cause the program to crash
</li><li>
will always cause the program to crash
</li></ol>
&nbsp;
</li><li>Consider the declaration <code>int y[3];</code>. As an rvalue, the expression <code>y[3]</code>:
<ol><li>
generates an out-of-bounds error message
</li><li>
references the last element in the array
</li><li>
may cause the program to crash
</li><li>
will always cause the program to crash
</li></ol>
&nbsp;
</li><li>Consider the declaration <code>int y[3];</code>. As an rvalue, the expression <code>y[4]</code>:
<ol><li>
generates an out-of-bounds error message
</li><li>
references the last element in the array
</li><li>
may cause the program to crash
</li><li>
will always cause the program to crash
</li></ol>
&nbsp;
</li><li>Consider the declaration <code>int y[3];</code>. The proper declaraction for a pointer that can point to array <i>y</i> is:
<ol><li>
<code>int *z;</code>
</li><li>
<code>int z;</code>
</li><li>
<code>int z(*[3]);</code>
</li><li>
<code>int *z[3];</code>
</li></ol>
&nbsp;
</li><li>Consider the declaration <code>char *y[3];</code>. The proper declaraction for a pointer that can point to array <i>y</i> is:
<ol><li>
<code>char *z;</code>
</li><li>
<code>char **z;</code>
</li><li>
<code>char *z(*[3]);</code>
</li><li>
<code>char *z[3];</code>
</li></ol>
&nbsp;
</li><li>Suppose <i>z</i> points to array <i>a</i>. To access the first element of <i>a</i> using <i>z</i>, one would use the expression:
<ol><li>
<code>z[0]</code>
</li><li>
<code>z[1]</code>
</li><li>
<code>*z[0]</code>
</li><li>
<code>*z[1]</code>
</li><li>
<code>z+0</code>
</li><li>
<code>z+1</code>
</li></ol>
&nbsp;
</li><li>Consider the declaration <code>int *y[3];</code>. To make the assignment <code>p = y;</code> legal, the declaration of <i>p</i> would have to be:
<ol><li>
<code>int ***p;</code>
</li><li>
<code>int **p;</code>
</li><li>
<code>int *p;</code>
</li><li>
<code>int p;</code>
</li></ol>
&nbsp;
</li><li>Consider the declaration <code>int **y[3];</code>. To make the assignment <code>p = y;</code> legal, the declaration of <i>p</i> would have to be:
<ol><li>
<code>int ***p;</code>
</li><li>
<code>int **p;</code>
</li><li>
<code>int *p;</code>
</li><li>
<code>int p;</code>
</li></ol>
&nbsp;
</li><li>Consider the declaration <code>int y[3];</code>. To make the assignment <code>p = y;</code> legal, the declaration of <i>p</i> would have to be:
<ol><li>
<code>int ***p;</code>
</li><li>
<code>int **p;</code>
</li><li>
<code>int *p;</code>
</li><li>
<code>int p;</code>
</li></ol>
&nbsp;
</li><li>Consider the declaration <code>char *y[3];</code>. To make the assignment <code>p[0] = y;</code> legal, the declaration of <i>p</i> would have to be:
<ol><li>
<code>char ***p;</code>
</li><li>
<code>char **p;</code>
</li><li>
<code>char *p;</code>
</li><li>
<code>char p;</code>
</li></ol>
&nbsp;
</li><li>Consider the declaration <code>char y[3];</code>. To make the assignment <code>p[0] = y;</code> legal, the declaration of <i>p</i> would have to be:
<ol><li>
<code>char ***p;</code>
</li><li>
<code>char **p;</code>
</li><li>
<code>char *p;</code>
</li><li>
<code>char p;</code>
</li></ol>
&nbsp;
</li><li>Consider the declaration <code>char **y[3];</code>. To make the assignment <code>p[0] = y[0];</code> legal, the declaration of <i>p</i> would have to be:
<ol><li>
<code>char ***p;</code>
</li><li>
<code>char **p;</code>
</li><li>
<code>char *p;</code>
</li><li>
<code>char p;</code>
</li></ol>
&nbsp;
</li><li>Consider the declaration <code>char *y[3];</code>. To make the assignment <code>p[0] = y;</code> legal, the declaration of <i>p</i> would have to be:
<ol><li>
<code>char ***p;</code>
</li><li>
<code>char **p;</code>
</li><li>
<code>char *p;</code>
</li><li>
<code>char p;</code>
</li></ol>
&nbsp;
</li><li><b>T</b> or <b>F</b>: Given the declaration <code>int x[3];</code> and <code>int y[3];</code>, then <code>x = y;</code> will cause a compiler error.
&nbsp;<br />&nbsp;<br />&nbsp;
</li><li><b>T</b> or <b>F</b>: Given the declaration <code>int x[3];</code> and <code>int y[3];</code>, then <code>y = x;</code> will cause a compiler error.
&nbsp;<br />&nbsp;<br />&nbsp;
</li><li><b>T</b> or <b>F</b>: Given the declaration <code>int x[3];</code> and <code>int y[3];</code>, then <code>y = x[0];</code> will cause a compiler error.
&nbsp;<br />&nbsp;<br />&nbsp;
</li><li><b>T</b> or <b>F</b>: Given the declaration <code>int x[3];</code> and <code>int y[3];</code>, then <code>y[0] = x;</code> will cause a compiler error.
&nbsp;<br />&nbsp;<br />&nbsp;
</li><li>Consider the declaration <code>int z[3];</code>. The name <i>z</i> is:
<ol><li>
a pointer
</li><li>
a pseudopointer
</li><li>
neither a pointer nor a pseudopointer
</li></ol>
&nbsp;
</li><li><b>T</b> or <b>F</b>: You can assign a pointer to a pseudopointer.
&nbsp;<br />&nbsp;<br />&nbsp;
</li><li><b>T</b> or <b>F</b>: You can assign a pseudopointer to a pseudopointer.
&nbsp;<br />&nbsp;<br />&nbsp;
</li><li><b>T</b> or <b>F</b>: You can assign a pointer to a pointer.
&nbsp;<br />&nbsp;<br />&nbsp;
</li><li><b>T</b> or <b>F</b>: You can assign a pseudopointer to a pointer.
&nbsp;<br />&nbsp;<br />&nbsp;
</li><li>Using the <i>sizeof</i> operator on a pseudopointer to an array gives you:
<ol><li>
the number of slots in the array
</li><li>
the number of bytes in the array
</li><li>
the size of the pseudopointer
</li><li>
you are not allowed to use <i>sizeof</i> on a pseudopointer
</li></ol>
&nbsp;
</li><li>Using the <i>sizeof</i> operator on a pointer to an array gives you:
<ol><li>
the number of slots in the array
</li><li>
the number of bytes in the array
</li><li>
the size of the pointer
</li><li>
you are not allowed to use <i>sizeof</i> on a pointer
</li></ol>
&nbsp;
</li><li>Consider: 
<pre>
    int a[3];
    int *p = a;
</pre>
<p>The value stored at the memory location associated with <i>p</i> is:
</p>
<ol><li>
the address of the first slot of the array
</li><li>
the name <i>a</i>
</li><li>
the value of the first element of the array
</li><li>
undefined, since the operation is illegal
</li></ol>
&nbsp;
</li><li>Consider: 
<pre>
    int a[3];
    int *p = a;
</pre>
<p>The value stored at the memory address found in <i>p</i> is:
</p>
<ol><li>
the address of the first slot of the array
</li><li>
the name <i>a</i>
</li><li>
the value of the first element of the array
</li><li>
undefined, since the operation is illegal
</li></ol>
&nbsp;
</li><li>The array access <code>a[3]</code> can be rewritten as:
<ol><li>
<code>*(a + 2)</code>
</li><li>
<code>*(a + 3)</code>
</li><li>
<code>*(a) + 2</code>
</li><li>
<code>*(a) + 3</code>
</li></ol>
&nbsp;
</li><li>The pointer access <code>*(a+4)</code> can be rewritten as:
<ol><li>
<code>a[3]</code>
</li><li>
<code>a[4]</code>
</li><li>
<code>*(a[3])</code>
</li><li>
<code>*(a[4])</code>
</li></ol>
&nbsp;
</li><li>The array access <code>a[0]</code> cannot be rewritten as:
<ol><li>
<code>*(a + 2) - 2</code>
</li><li>
<code>*(a + 2 - 2)</code>
</li><li>
<code>*(a + 0)</code>
</li><li>
<code>*a</code>
</li></ol>
&nbsp;
</li><li>Consider: 
<pre>
    int a[] = { 10, 100, 100 };
    int *p = a;
</pre>
<p>The expression <i>p+1</i>:
</p>
<ol><li>
points to the first slot of <i>a</i>
</li><li>
points to the second slot of <i>a</i>
</li><li>
evaluates to 11
</li><li>
evaluates to 101
</li></ol>
&nbsp;
</li><li>Consider: 
<pre>
    int a[] = { 10, 100, 100 };
    int *p = a;
</pre>
<p>The expression <i>p+2</i>:
</p>
<ol><li>
points to the first memory location beyond <i>a</i>
</li><li>
points to the third slot of <i>a</i>
</li><li>
evaluates to 101
</li><li>
evaluates to 1001
</li></ol>
&nbsp;
</li><li>Consider: 
<pre>
    int a[] = { 10, 100, 100 };
    int *p = a;
</pre>
<p>The expression <i>p+3</i>:
</p>
<ol><li>
points to the first memory location beyond <i>a</i>
</li><li>
points to the third slot of <i>a</i>
</li><li>
evaluates to 1001
</li><li>
would generate an error by the compiler
</li></ol>
&nbsp;
</li><li>The standard library function that can be used to dynamically allocate an array is called:
<ol><li>
<i>malloc</i>
</li><li>
<i>allocate</i>
</li><li>
<i>dallocate</i>
</li><li>
<i>dymalloc</i>
</li></ol>
&nbsp;
</li><li>The string <code>"dog"</code> is stored as:
<ol><li>
an array of three characters
</li><li>
an array of four characters
</li><li>
a single location in memory
</li><li>
three non-contiguous memory locations
</li></ol>
&nbsp;
</li><li>A pointer to the string <code>"rat"</code> has the type:
<ol><li>
char
</li><li>
char *
</li><li>
char [3]
</li><li>
string
</li><li>
string *
</li></ol>
&nbsp;
</li><li>Consider a pointer <i>p</i> to the string <code>"bat"</code>. What is the rvalue of <code>p[1]</code>?
<ol><li>
the second memory location in the string
</li><li>
the letter <code>'b'</code>
</li><li>
the letter <code>'a'</code>
</li><li>
the first memory location in the string
</li></ol>
&nbsp;
</li><li>Consider a pointer <i>p</i> to the string <code>"bat"</code>. What is the lvalue of <code>p[1]</code>?
<ol><li>
the second memory location in the string
</li><li>
the letter <code>'b'</code>
</li><li>
the letter <code>'a'</code>
</li><li>
the first memory location in the string
</li></ol>
&nbsp;
</li><li>Consider a pointer <i>p</i> to the string <code>"bat"</code>. What is the rvalue of <code>p[3]</code>?
<ol><li>
unknown
</li><li>
the letter <code>'t'</code>
</li><li>
the null character
</li><li>
the last memory location in the string
</li></ol>
&nbsp;
</li><li>Consider a pointer <i>p</i> to the string <code>"bat"</code>. What is the lvalue of <code>p[4]</code>?
<ol><li>
the first memory location beyond the string
</li><li>
the second memory location beyond the string
</li><li>
unknown
</li><li>
the null character
</li></ol>
</li></ol>
<a name="ContentsArrays"></a>
<address><a href="mailto:lusth@cs.ua.edu"><p>lusth@cs.ua.edu</a></address><br />
<table width="100%" cellpadding=0 cellspacing=2><tr><td bgcolor="#b2b2b2" ><a href="index_4.html">
  <img border="0" alt="An Introduction to Order Notation" src="previous.png"></a></td><td bgcolor="#b2b2b2" ><a href="index.html">
  <img border="0" alt="Top" src="up.png"></a></td><td bgcolor="#b2b2b2" ><a href="index_6.html">
  <img border="0" alt="Fillable Arrays" src="next.png"></a></td><td bgcolor="#b2b2b2" align="center" width="100%"><font color="#000000"><b></b></font>
    </td><td bgcolor="#b2b2b2" align="center"><a href="index_1.html">Contents</a></td></td></tr></table></body></html>
