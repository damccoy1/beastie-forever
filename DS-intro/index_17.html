<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- XML file produced from file: index.tex
     using Hyperlatex v 2.9-in-waiting-rk (oct06) (c) Otfried Cheong
     on Emacs 22.2.1, Mon Aug 18 09:08:15 2014 -->
<head>
<title>An Encyclop&aelig;dia of Elementary Data Structures -- Binary Search Trees</title>

<style type="text/css">
.maketitle { align : center }
div.abstract { margin-left: 20%; margin-right: 10%; }
h3.abstract  { align : center }
div.verse, div.quote, div.quotation {
  margin-left : 10%; 
  margin-right : 10%;
}
dt {font-weight: bold}
</style>
</p>
<link rel=stylesheet
        href="lusth.css" type="text/css" />
</head>
<body>
<table width="100%" cellpadding=0 cellspacing=2><tr><td bgcolor="#b2b2b2" ><a href="index_16.html">
  <img border="0" alt="Binary Trees" src="previous.png"></a></td><td bgcolor="#b2b2b2" ><a href="index.html">
  <img border="0" alt="Top" src="up.png"></a></td><td bgcolor="#b2b2b2" ><a href="index_18.html">
  <img border="0" alt="Heaps" src="next.png"></a></td><td bgcolor="#b2b2b2" align="center" width="100%"><font color="#000000"><b></b></font>
    </td><td bgcolor="#b2b2b2" align="center"><a href="index_1.html">Contents</a></td></td></tr></table>
<h1>Binary Search Trees</h1>

<h2><a name="id1">Synopsis</a></h2><p>
A binary search tree is a binary tree where the nodes
in the tree are ordered by ther values. Usually nodes on
the left side are "less than" than those on the right side of the
tree, recursively. When we say a node <i>A</i> is less than a node <i>B</i>,
we mean the
value stored at node <i>A</i> is less than the value stored at node <i>B</i>.
More specifically, the following rules apply at any point in the tree.
</p>
<ul><li>a left-child node is less than or equal to its parent
</li><li>a right-child node is equal to or greater than its parent
</li></ul>

<h2><a name="id2">Structure</a></h2>
<pre>
    class binaryTreeNode
        {
        var value;
        var left;
        var right;
        var parent;            //optional
        }

    class binarySearchTree
        {
        var root;               //the top-level binary tree node
        // operations
        ...
        }
</pre>

<h2><a name="id3">Vocabulary</a></h2><p>
The terms used in describing a binary search tree are
the same as those describing a generic
<a href="index_16.html">binary tree</a>.
</p>

<h2><a name="id4">Supports</a></h2><p>
Binary search trees are considered top-level data structures.
</p>

<h2><a name="id5">Dependencies</a></h2><p>
Binary search trees are based upon tree 
<a href="index_10.html">nodes</a>.
</p>

<h2><a name="id6">Operations</a></h2><p>
The operation descriptions assume unique values in the tree,
with values to the left less than those to the right.
For trees with duplicate
values or a reversed ordering, appropriate modifications to the descriptions should
be made.
</p>

<h3><a name="id7">insert</a></h3><p>
The typical insertion strategy looks like this:
</p>
<ul><li>create a node <i>n</i> containing the given value to insert
</li><li>call a helper function with the <i>root</i> and node <i>n</i>
</li></ul>
<p>The helper function implements this straegy, with <i>current</i>
referring to its first argument and <i>n</i> refering to the second:
</p>
<pre>
    if node n is less than the current node //n must belong on left side of tree
        if the current node has no left child
            set the left child pointer of the current node to n
        else 
            recur, passing the left child and n to the helper
     else //n must belong on right side of tree
         if the current node has no right child
            set the right child pointer of the current node to n
         else
            recur, passing the right child and n to the helper
</pre>
<p>A special case exists if the tree is empty, since the root pointer
will need to be set.
Inserting a value into a binary tree can take linear time, if the tree is pathologically unbalanced.
</p>

<h3><a name="id8">find</a></h3>

<h3><a name="id9">delete</a></h3><p>
There are a number of deletion strategies. One that preserves the
existing balance of the tree to some degree is as follows...
</p>

<h2><a name="id10">Traversals</a></h2><p>
Traversals for binary search trees are the same as those
of
<a href="index_16.html#BinaryTreesTraversals">binary trees</a>.
</p>

<h2><a name="id11">Concept Inventory</a></h2>
<div align="center">
</div>
<ol>&nbsp;
<li>Consider a binary search tree with <i>n</i> nodes. What is the best case time complexity for finding a value at a leaf?
<ol><li>
constant
</li><li>
log <i>n</i>
</li><li>
<i>sqrt(n)</i>
</li><li>
linear
</li><li>
<i>n</i> log <i>n</i>
</li><li>
quadratic
</li></ol>
&nbsp;
</li><li>Consider a binary search tree with <i>n</i> nodes. What is the worst case time complexity for finding a value at a leaf?
<ol><li>
constant
</li><li>
log <i>n</i>
</li><li>
<i>sqrt(n)</i>
</li><li>
linear
</li><li>
<i>n</i> log <i>n</i>
</li><li>
quadratic
</li></ol>
&nbsp;
</li><li>Which ordering of input values builds the most unbalanced BST? Assume values are inserted from left to right.
<ol><li>
2
</li><li>
3
</li><li>
1
</li></ol>
&nbsp;
</li><li>Which ordering of input values builds the most balanced BST? Assume values are inserted from left to right.
<ol><li>
5
</li><li>
7
</li><li>
8
</li></ol>
&nbsp;
</li><li>For all child nodes in a BST, what relationship holds between the value of a child node and the value of its parent?
<ol><li>
greater than or equal to
</li><li>
less than or equal to
</li><li>
greater than or equal to, if the child is a right child
</li><li>
less than or equal to, if the child is a right child
</li><li>
there is no relationship
</li></ol>
&nbsp;
</li><li>For all sibling nodes in a BST, what relationship holds between the value of a left child node and the value of its sibling?
<ol><li>
greater than or equal to
</li><li>
less than or equal to
</li><li>
equal to
</li><li>
there is no relationship
</li></ol>
&nbsp;
</li><li>Do all these deletion strategies for non-leaf nodes reliably preserve BST ordering? 
<ul>
<li>Swap the values of the node to be deleted and the smallest leaf node with a larger value, then remove the leaf.
</li><li>Swap the values of the node to be deleted with its predecessor or successor. If the predecessor or successor is a leaf, remove it. Otherwise, repeat the process.
</li><li>If the node to be deleted does not have two children, simply connect the parent's child pointer to the node to the node's child pointer, otherwise, use a correct deletion strategy for nodes with two children.
&nbsp;<br /></li></ul>
<ol><li>
true
</li><li>
false
</li></ol>
</li></ol>
<address><a href="mailto:lusth@cs.ua.edu"><p>lusth@cs.ua.edu</a></address><br />
<table width="100%" cellpadding=0 cellspacing=2><tr><td bgcolor="#b2b2b2" ><a href="index_16.html">
  <img border="0" alt="Binary Trees" src="previous.png"></a></td><td bgcolor="#b2b2b2" ><a href="index.html">
  <img border="0" alt="Top" src="up.png"></a></td><td bgcolor="#b2b2b2" ><a href="index_18.html">
  <img border="0" alt="Heaps" src="next.png"></a></td><td bgcolor="#b2b2b2" align="center" width="100%"><font color="#000000"><b></b></font>
    </td><td bgcolor="#b2b2b2" align="center"><a href="index_1.html">Contents</a></td></td></tr></table></body></html>
